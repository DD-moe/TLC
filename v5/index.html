<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QTLC v5</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>
    <script src="https://docs.opencv.org/4.7.0/opencv.js" async></script>
    <!-- warning: loading OpenCV can take some time. Load asynchronously -->
    <script src="https://cdn.jsdelivr.net/gh/ColonelParrot/jscanify@master/src/jscanify.min.js"></script>
    <script src="https://git.1ioe.top/TLC/v5/params.js"></script><!-- wej≈õcia parametr√≥w, ui dla parametr√≥w i local storage -->
    <script src="https://git.1ioe.top/TLC/v5/counting.js"></script><!-- obliczanie parametr√≥w plamek -->
    <!-- load them both always-->
    <script type="module" src="https://utils.1ioe.top/paint.js" blocking="render"></script><!-- w≈Çasny element do rysowania na canvas -->
    <script src="https://git.1ioe.top/TLC/v5/averaging.js"></script><!-- obliczanie parametr√≥w plamek -->
    <!-- load them both always-->
    <script src="https://git.1ioe.top/TLC/v5/plate.js"></script><!-- obliczanie parametr√≥w plamek -->
    <style>
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
            height: auto;
            width: auto;
            margin: 0 auto;
            border: 1px solid #ccc; /* opcjonalnie dla widoczno≈õci */
        }
    </style>
</head>

<body class="bg-white text-dark py-4">
</body>


<script>

//################################# - funkcje do preprocess

    // funkcja do wstƒôpnego przetwarzania po za≈ÇƒÖdowaniu pierwszej p≈Çytki
    function pre_process(id, canvas, sources, processed_sources) {
        corners = assignCorners(detectBrightCorners(id, canvas));
        console.log(corners);  // 4 punkty najbli≈ºsze naro≈ºnikom
        // przetwarza w≈Ça≈õciwie ten obraz
        mid_process(id, canvas, sources, processed_sources);
    }

//################################# - funkcje do preprocess

//################################# - funkcje do w≈Ça≈õciwego przetwarzania


    // custom implementation of polynomial reggression
    function polynomialRegression(data, degree) {
        const X = [];
        const Y = [];

        // Rozdziel dane
        for (const point of data) {
            X.push(point.x);
            Y.push(point.y);
        }

        const N = degree + 1;
        const matrix = Array.from({ length: N }, () => Array(N + 1).fill(0));

        // Wype≈Çnij macierz uk≈Çadu r√≥wna≈Ñ normalnych
        for (let row = 0; row < N; row++) {
            for (let col = 0; col < N; col++) {
                matrix[row][col] = X.reduce((sum, xi) => sum + Math.pow(xi, row + col), 0);
            }
            matrix[row][N] = X.reduce((sum, xi, i) => sum + Y[i] * Math.pow(xi, row), 0);
        }

        // RozwiƒÖzywanie uk≈Çadu r√≥wna≈Ñ metodƒÖ Gaussa
        for (let i = 0; i < N; i++) {
            // Szukamy maksymalnego elementu w kolumnie
            let maxRow = i;
            for (let k = i + 1; k < N; k++) {
                if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxRow][i])) {
                    maxRow = k;
                }
            }
            [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];

            // Eliminacja
            for (let k = i + 1; k < N; k++) {
                const factor = matrix[k][i] / matrix[i][i];
                for (let j = i; j <= N; j++) {
                    matrix[k][j] -= factor * matrix[i][j];
                }
            }
        }

        // Podstawianie wsteczne
        const coeffs = Array(N).fill(0);
        for (let i = N - 1; i >= 0; i--) {
            coeffs[i] = matrix[i][N] / matrix[i][i];
            for (let k = i - 1; k >= 0; k--) {
                matrix[k][N] -= matrix[k][i] * coeffs[i];
            }
        }

        return coeffs; // wsp√≥≈Çczynniki od wyrazu wolnego (x^0) do najwy≈ºszego (x^n)
    }

    // predykcja wynik√≥w
    function predictY(coeffs, x) {
        return coeffs.reduce((sum, a, i) => sum + a * Math.pow(x, i), 0);
    }


    // polynomial reggression light normalization
     /*
     * Przetwarza kolumny z pomniejszonego obrazu za pomocƒÖ regresji wielomianowej
     * i wype≈Çnia pe≈Çne dane predykcjami RGB.
     *
     * @param {Uint8ClampedArray} min_data - Dane obrazu pomniejszonego (ImageData.data)
     * @param {number} scale - Skala pomniejszenia (np. 4 je≈õli pomniejszony obraz ma 1/4 wysoko≈õci)
     * @param {Uint8ClampedArray} full_data - Dane obrazu pe≈Çnego (ImageData.data)
     * @param {number} width - Szeroko≈õƒá pe≈Çnego obrazu
     * @param {number} height - Wysoko≈õƒá pe≈Çnego obrazu
     * @param {number} smallWidth - Szeroko≈õƒá pomniejszonego obrazu
     * @param {number} smallHeight - Wysoko≈õƒá pomniejszonego obrazu
     */
    function processColumnsWithPolynomialRegression(min_data, scale, full_data, width, height, smallWidth, smallHeight) {
        for (let x = 0; x < smallWidth; x++) {
            const data = [];

            // Zbieranie danych treningowych z RED kana≈Çu pomniejszonego obrazu
            for (let y = 0; y < smallHeight; y++) {
                const index = (y * smallWidth + x) * 4;
                const red = min_data[index];
                data.push({ x: y * scale, y: red });  // x = rzeczywista pozycja w pe≈Çnym obrazie
            }

            // Trenuj model
            const { model } = iterativePolynomialRegression(data);

            // Predykcja dla pe≈Çnego obrazu
            for (let y = 0; y < height; y++) {
                const predicted = model(y);
                const fullIndex = (y * width + x) * 4;

                const clamped = Math.max(0, Math.min(255, Math.round(predicted - full_data[fullIndex])));

                
                full_data[fullIndex] = clamped;     // R
                full_data[fullIndex + 1] = clamped; // G
                full_data[fullIndex + 2] = clamped; // B
                // Alpha kana≈Ç zostaje nietkniƒôty
            }
        }
    }


    // obliczanie regresji wielomianowej w modelu iteracyjnym
    /**
     * Iteracyjna regresja z odrzucaniem danych o najwiƒôkszym b≈Çƒôdzie.
     * @param {Array<{x: number, y: number}>} data - Dane wej≈õciowe.
     * @returns {Object} Obiekt z ko≈Ñcowym modelem, oczyszczonymi danymi i historiƒÖ b≈Çƒôd√≥w.
     */
    function iterativePolynomialRegression(data) {
        const originalLength = data.length;
        let currentData = [...data];
        let previousAvgErrorFactor = Infinity;
        let history = [];

        while (true) {
            const coeffs = polynomialRegression(currentData, 3); // zamiennik model.getTerms()

            // Oblicz b≈Çƒôdy
            const errors = currentData.map(point => {
                const predictedY = predictY(coeffs, point.x);
                const error = predictedY - point.y;
                return { ...point, error };
            });

            // ≈öredni b≈ÇƒÖd
            const avgError = errors.reduce((sum, e) => sum + e.error, 0) / errors.length;

            // Factor: aktualna liczba danych / pierwotna liczba danych
            const factor = currentData.length / originalLength;
            const avgErrorFactor = avgError / factor;

            history.push({
                dataLength: currentData.length,
                avgError,
                factor,
                avgErrorFactor
            });

            // Warunek zako≈Ñczenia
            if (
                //avgErrorFactor > previousAvgErrorFactor ||
                currentData.length <= originalLength / 2.5 // INPUT*
            ) {
                break;
            }

            previousAvgErrorFactor = avgErrorFactor;

            // Usu≈Ñ 10% punkt√≥w z najwiƒôkszym b≈Çƒôdem
            const threshold = Math.ceil(currentData.length * 0.10); // INPUT*
            errors.sort((a, b) => b.error - a.error);
            currentData = errors.slice(threshold).map(e => ({ x: e.x, y: e.y }));
        }

        const finalCoeffs = polynomialRegression(currentData, 3);

        return {
            coeffs: finalCoeffs,          // wsp√≥≈Çczynniki ko≈Ñcowego modelu
            model: x => predictY(finalCoeffs, x), // funkcja do przewidywania
            cleanedData: currentData,
            history
        };
    }


    // funkcja do ekstrakcji niezlewajƒÖcych siƒô plamek 2d
    function extractBlobsFromCanvas(id, sourceCanvas) {

        // zak≈Çadamy zmienne bazowe:
        const treshold =  20; // INPUT*
        const edgeThickness = 10; // INPUT*

        // 1. Usu≈Ñ istniejƒÖcy kontener
        const existing = document.getElementById(`${id}_mid_process_blobs`);
        if (existing) existing.remove();

        // 2. Utw√≥rz kontener Bootstrap
        const container = document.createElement('div');
        container.className = 'container bg-light p-3';
        container.id = `${id}_mid_process_blobs`;

        // 3. Nag≈Ç√≥wek
        const heading = document.createElement('h1');
        heading.className = 'mb-4';
        heading.textContent = 'Ekstrakcja plamek';
        container.appendChild(heading);

        // 4. pobierz canvas z rozmyciem 1px
        const detectedCanvas = document.createElement('canvas');
        detectedCanvas.width = sourceCanvas.width;
        detectedCanvas.height = sourceCanvas.height;
        detectedCanvas.id = `midCanvas-blobs-${id}`;

        let src = cv.imread(sourceCanvas); // Wczytaj obraz RGBA
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); // Konwertuj na grayscale
        // Zamaskuj ramkƒô - 5px od ka≈ºdej krawƒôdzi
        gray.rowRange(0, edgeThickness).setTo(new cv.Scalar(0)); // g√≥ra
        gray.rowRange(gray.rows - edgeThickness, gray.rows).setTo(new cv.Scalar(0)); // d√≥≈Ç
        gray.colRange(0, edgeThickness).setTo(new cv.Scalar(0)); // lewa
        gray.colRange(gray.cols - edgeThickness, gray.cols).setTo(new cv.Scalar(0)); // prawa


        // Progowanie jasnych obszar√≥w: wszystko powy≈ºej 10
        let thresh = new cv.Mat();
        cv.threshold(gray, thresh, treshold, 255, cv.THRESH_BINARY);

        // Operacje morfologiczne: oczyszczanie i rozszerzenie
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.morphologyEx(thresh, thresh, cv.MORPH_OPEN, kernel);
        cv.dilate(thresh, thresh, kernel);

        // Znajd≈∫ kontury
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let boxes = [];
        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let rect = cv.boundingRect(cnt);

            if (rect.width * rect.height > 10) { // Odrzuƒá drobne zak≈Ç√≥cenia // INPUT*
                let expandX = Math.round(rect.width * 0.08);
                let expandY = Math.round(rect.height * 0.08);

                let x = Math.max(0, rect.x - expandX);
                let y = Math.max(0, rect.y - expandY);
                let width = Math.min(src.cols - x, rect.width + 2 * expandX);
                let height = Math.min(src.rows - y, rect.height + 2 * expandY);

                let point1 = new cv.Point(x, y);
                let point2 = new cv.Point(x + width, y + height);
                cv.rectangle(src, point1, point2, [0, 255, 0, 255], 2);
                boxes.push({ x, y, width, height });
            }

            cnt.delete();
        }

        cv.imshow(detectedCanvas, src);

        // Zwolnienie pamiƒôci
        src.delete(); gray.delete(); thresh.delete();
        kernel.delete(); contours.delete(); hierarchy.delete();


        let ctx = sourceCanvas.getContext("2d");
        for (let box of boxes) {
            box.imageData = ctx.getImageData(box.x, box.y, box.width, box.height);
        }

        container.appendChild(detectedCanvas);
        document.body.appendChild(container);

        return boxes;
    }

    // funkcja do maskowania niezlewajƒÖcych siƒô plamek 2d
    function maskDarkest5Percent(boxes, percent) {
        return boxes.map(box => {
            const { imageData } = box;
            const { data, width, height } = imageData;
            const pixelCount = width * height;

            // Tworzymy tablicƒô: { index, red } ‚Äî jeden element na ka≈ºdy piksel
            let redValues = [];
            for (let i = 0; i < data.length; i += 4) {
                redValues.push({ index: i, red: data[i] }); // data[i] = kana≈Ç R
            }

            // Sortujemy rosnƒÖco po czerwonym kanale
            redValues.sort((a, b) => a.red - b.red);

            // Ile to jest 5%?
            const thresholdCount = Math.floor(pixelCount * percent / 100);

            // Iterujemy po 5% najciemniejszych i maskujemy RGB
            for (let i = 0; i < thresholdCount; i++) {
                const idx = redValues[i].index;
                data[idx] = 0;     // R
                data[idx + 1] = 0; // G
                data[idx + 2] = 0; // B
                // data[idx + 3] = alfa ‚Äî NIE ruszamy
            }

            // Tworzymy nowy ImageData i przypisujemy do box
            box.imageData = new ImageData(data, width, height);
            return box;
        });
    }  

    // funkcja do w≈Ça≈õciwego przetwarzania danych:
    function mid_process(id, canvas, sources, processed_sources) {

        if (mode === 'normalise') { // protok√≥≈Ç uproszczony dla normalizacji fizycznej o≈õwietlenia
            addCommentCell(id+'_commentHeader', `dla obrazu: ${id}`, document.body);
            const extracted_canvas = extractDocumentFromCanvas(id, canvas);
            let boxes = extractBlobsFromCanvas(id, extracted_canvas); 
            boxes = maskDarkest5Percent(boxes, 15); // INPUT* (ile procent odrzuciƒá)
            processed_sources[id] = boxes;
            sources[id] = extracted_canvas;
        }
        else if (mode === 'unnormalise') { // protok√≥≈Ç dla zdjƒôƒá bez normalizacji fizycznej o≈õwietlenia
            addCommentCell(id+'_commentHeader', `dla obrazu: ${id}`, document.body);
            const extracted_canvas = extractDocumentFromCanvas_norm(id, canvas);
            let boxes = extractBlobsFromCanvas(id, extracted_canvas); 
            boxes = maskDarkest5Percent(boxes, 15); // INPUT*
            processed_sources[id] = boxes;
            sources[id] = extracted_canvas;
        }

        console.log("mid_process wywo≈Çane z sources:", id, canvas);
    }
//################################# - funkcje do w≈Ça≈õciwego przetwarzania ^ dla mid_process



//################################# - funkcje do postprocesingu

    // funkcja do ko≈Ñcowego przetwarzania danych
    function final_process(sources, processed_sources) {
        console.log("final_process wywo≈Çane z sources:", processed_sources);

        // Iteracja w kolejno≈õci dodania (klucze obiekt√≥w w JS zachowujƒÖ kolejno≈õƒá)
        Object.keys(sources).forEach(id => {
            const sourceCanvas = sources[id];
            const processedData = processed_sources[id];
            addCommentCell(id+'_outputsHeader', `Wyniki dla obrazu: ${id}`, document.body);

            // Przetw√≥rz dane przez analizator
            const spots= postprocess_analysis(processedData);

            // Stw√≥rz kontener

            // G≈Ç√≥wna karta
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'card mb-4';

            // Nag≈Ç√≥wek z przyciskami toggle
            const cardHeader = document.createElement('div');
            cardHeader.className = 'card-header d-flex gap-2 flex-wrap';

            const toggleMain = document.createElement('button');
            toggleMain.className = 'btn btn-sm btn-outline-primary';
            toggleMain.type = 'button';
            toggleMain.setAttribute('data-bs-toggle', 'collapse');
            toggleMain.setAttribute('data-bs-target', `#collapse-main-${id}`);
            toggleMain.textContent = 'Poka≈º/Wy≈ÇƒÖcz obraz';

            const toggleDesc = document.createElement('button');
            toggleDesc.className = 'btn btn-sm btn-outline-secondary';
            toggleDesc.type = 'button';
            toggleDesc.setAttribute('data-bs-toggle', 'collapse');
            toggleDesc.setAttribute('data-bs-target', `#collapse-desc-${id}`);
            toggleDesc.textContent = 'Poka≈º/Wy≈ÇƒÖcz opis';

            cardHeader.appendChild(toggleMain);
            cardHeader.appendChild(toggleDesc);
            cardWrapper.appendChild(cardHeader);

            // Kontener na sekcjƒô: ( obraz + przyciski )
            const container = document.createElement('div');
            container.className = 'collapse show';
            container.id = `collapse-main-${id}`;
            container.classList.add('card-body');

            // Kontener na obraz + przyciski
            const img_container = document.createElement('div');
            img_container.className = 'canvas-result mb-4';
            img_container.id = `image_show-${id}`;
            img_container.style.position = 'relative';  // Pozycjonowanie wzglƒôdem tego kontenera
            container.appendChild(img_container);

            // Kontener na opis/tabelƒô
            const description_container = document.createElement('div');
            description_container.className = 'collapse show row g-3';
            description_container.id = `collapse-desc-${id}`;
            description_container.classList.add('card-body');

            // Dodaj oba kontenery do g≈Ç√≥wnej karty
            cardWrapper.appendChild(container);
            cardWrapper.appendChild(description_container);

            // Stw√≥rz kopiƒô canvasu
            // 1. Konwersja do PNG (base64)
            const pngDataURL = sourceCanvas.toDataURL('image/png');

            // 2. Tworzymy <img> z zakodowanym PNG
            const imageElement = document.createElement('img');
            imageElement.src = pngDataURL;
            imageElement.alt = `Wynik ${id}`;
            imageElement.style.display = 'block';
            imageElement.style.width = '100%';  // bardzo wa≈ºne, by obraz siƒô skalowa≈Ç wzglƒôdem kontenera
            imageElement.style.border = '1px solid #ccc';

            img_container.appendChild(imageElement);

            // Poczekaj, a≈º obraz siƒô za≈Çaduje, aby znaƒá jego wymiary
            imageElement.onload = () => {
                const imgWidth = imageElement.naturalWidth;
                const imgHeight = imageElement.naturalHeight;

                spots.forEach((spot, index) => {
                    const { x, y, width, height } = spot;

                    const btn = document.createElement('button');
                    btn.textContent = `${id}#${index}`;
                    btn.style.position = 'absolute';

                    // Pozycjonuj wzglƒôdem oryginalnych wymiar√≥w obrazu
                    btn.style.left = `${(x / imgWidth) * 100}%`;
                    btn.style.top = `${(y / imgHeight) * 100}%`;
                    btn.style.width = `${(width / imgWidth) * 100}%`;
                    btn.style.height = `${(height / imgHeight) * 100}%`;

                    btn.style.background = 'rgba(255,0,0,0.3)';
                    btn.style.border = '1px solid red';
                    btn.style.color = 'yellow';
                    btn.style.fontSize = '10px';
                    btn.style.cursor = 'pointer';
                    btn.title = `Plamka ${index}`;

                    btn.addEventListener('click', () => {
                        const tableRow = document.getElementById(`spot-${id}-${index}`);
                        if (tableRow) {
                            tableRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            tableRow.style.backgroundColor = 'yellow';
                            setTimeout(() => {
                                tableRow.style.backgroundColor = '';
                            }, 1000);
                        }
                    });

                    img_container.appendChild(btn);

            // Tworzenie tabeli parametr√≥w

                        // Wrapper kolumny dla tabeli
                        const colWrapper = document.createElement('div');
                        colWrapper.className = 'col-12 col-md-6 col-lg-4'; // pe≈Çna szeroko≈õƒá w mobile, 2 kolumny na md, 3 na lg+

                        // Nag≈Ç√≥wek nad tabelƒÖ
                        const caption = document.createElement('h6');
                        caption.textContent = `Parametry Plamki #${index}`;
                        caption.className = 'fw-bold mb-2';

                        // Tabela
                        const table = document.createElement('table');
                        table.className = 'table table-sm table-bordered table-striped w-100';

                        // Iteracja po danych
                        Object.entries(spot).forEach(([key, value]) => {
                            if (key === 'imageData') return;
                            if (key === 'chartX') return;
                            if (key === 'chartY') return;

                            const row = document.createElement('tr');
                            row.id = `spot-${id}-${index}`;

                            const cellKey = document.createElement('td');
                            cellKey.textContent = key;
                            cellKey.className = 'fw-light';

                            const cellValue = document.createElement('td');
                            cellValue.textContent = value;

                            row.appendChild(cellKey);
                            row.appendChild(cellValue);
                            table.appendChild(row);
                        });

                        // Sk≈Çadanie ca≈Ço≈õci
                        colWrapper.appendChild(caption);
                        colWrapper.appendChild(table);
                        description_container.appendChild(colWrapper);        
                });
            };

            // Umie≈õƒá ca≈Çy wynik na stronie
            document.body.appendChild(cardWrapper);
        });
    }

//################################# - funkcje do postprocesingu


//################################# - funkcje dla przycisk√≥ akcji
// zmienia parametry wymagajƒÖce zmiany
function applyConfigChanges(){
    mode = getString('normalisation_mode', 'unnormalise'); // 'normalise' , 'unnormalise' // INPUT* 
}
// czy≈õci dane przetworzone
function clearSources() {
    sources = {};
    processed_sources = {};
    alert('Dane ≈∫r√≥d≈Çowe i wyniki zosta≈Çy wyczyszczone.');
}


function convertTableUnits() { // do wyrzucenia
    // przyjmujemy, ≈ºe 1 px przypada na d≈Çugo≈õƒá boku p≈Çtyki
    // przyjmujemy, ≈ºe p≈Çytka ma 10 cm

    const keyWords_mm2 = [ 'spotSurface'];
    const keyWords_mm = ['x', 'y', 'width', 'height'];
    const allTables = document.querySelectorAll("table");

    allTables.forEach(table => {
        const rows = table.querySelectorAll("tr");
        rows.forEach(row => {
            const cells = row.querySelectorAll("td, th");
            if (cells.length < 2) return;

            const label = cells[0].innerText.trim();
            const valueCell = cells[1];

            const text = valueCell.innerText.trim();

            // Dopasuj liczby i jednostki
            const match = text.match(/^([0-9.,]+)\s*(mm¬≤|mm)?$/i);
            if (!match) return;

            let number = parseFloat(match[1].replace(",", "."));
            const unit = match[2]?.toLowerCase();

            if (keyWords_mm2.includes(label)) {
                if (!unit) {
                    // Bez jednostki, liczba w px¬≤ ‚Üí przelicz na mm¬≤
                    number = number * 0.01;
                    valueCell.innerText = number.toFixed(2) + " mm¬≤";
                } else if (unit === 'mm¬≤') {
                    // Jest mm¬≤ ‚Üí przelicz na px¬≤
                    number = number / 0.01;
                    valueCell.innerText = Math.round(number); // bez jednostki
                }
            } else if (keyWords_mm.includes(label)) {
                if (!unit) {
                    // Bez jednostki, liczba w px ‚Üí przelicz na mm
                    number = number * 0.1;
                    valueCell.innerText = number.toFixed(2) + " mm";
                } else if (unit === 'mm') {
                    // Jest mm ‚Üí przelicz na px
                    number = number / 0.1;
                    valueCell.innerText = Math.round(number); // bez jednostki
                }
            }
        });
    });
}
//################################# - funkcje dla przycisk√≥ akcji


//################################# - funkcje do definiowania przep≈Çywu pracy

    // funkcja obs≈ÇugujƒÖca kolejno≈õƒá przep≈Çywu przetwarzania
    function handleCanvasInput(canvas, id, sources, processed_sources, limit) {
        const currentSize = Object.keys(sources).length;

        // Zapisz canvas do sources
        sources[id] = canvas;

        if (limit <= 0) {
            console.warn("Niepoprawna warto≈õƒá limitu:", limit);
            return;
        }

        if (limit === 1) {
            pre_process(id, canvas, sources, processed_sources);
            final_process(sources, processed_sources);
        } else if (limit === 2) {
            if (currentSize === 0) {
                pre_process(id, canvas, sources, processed_sources);
            } else if (currentSize === 1) {
                mid_process(id, canvas, sources, processed_sources);
                final_process(sources, processed_sources);
            }
        } else { // limit >= 3
            if (currentSize === 0) {
                pre_process(id, canvas, sources, processed_sources);
            } else if (currentSize < limit - 1) {
                mid_process(id, canvas, sources, processed_sources);
            } else if (currentSize === limit - 1) {
                mid_process(id, canvas, sources, processed_sources);
                final_process(sources, processed_sources);
            }
        }
    }


    // wywo≈Çywany po ka≈ºdym za≈Çadowaniu ew. u≈õrednieniu obrazu
    window.addEventListener('newScan', (e) => {
        handleCanvasInput(e.detail.canvas, e.detail.id, sources, processed_sources, limit);
    });

//################################# - funkcje do definiowania przep≈Çywu pracy    

//*********************************
// Przyk≈Çad aplikacji TLC w frameworku low-code (JavaScript)
// Autor: [Twoje Imiƒô]
// Cel: Analiza TLC na podstawie 3 obraz√≥w ‚Äì UV 254 nm, UV 365 nm i ≈õwiat≈Ço zielone
// Ten kod tworzy aplikacjƒô za pomocƒÖ gotowych funkcji wysokiego poziomu.
//*********************************

// üü© Komentarze opisujƒÖ ka≈ºdƒÖ sekcjƒô zrozumiale dla cz≈Çowieka i AI.

// 1Ô∏è‚É£ Dodajemy komentarze/etykiety opisujƒÖce kolejne sekcje aplikacji.
// Funkcja addCommentCell(id, tekst, element_docelowy) dodaje komentarz HTML do interfejsu.

// 2Ô∏è‚É£ Dodajemy panele do ≈Çadowania obraz√≥w dla 3 r√≥≈ºnych ≈∫r√≥de≈Ç.
// Funkcja images(id, trigger) tworzy panel ≈Çadowania obraz√≥w.
// - id: unikalny identyfikator
// - trigger: true = uruchom przetwarzanie automatycznie po za≈Çadowaniu
addCommentCell('comment-1', 'Za≈Çaduj obraz dla UV 254 nm', document.body);
images("uv-254", true);

// i powtarzamy schemat

/*
addCommentCell('comment-2', 'Za≈Çaduj obraz dla UV 365 nm', document.body);
images("uv-365", true);

addCommentCell('comment-3', 'Za≈Çaduj obraz w ≈õwietle zielonym (widzialnym)', document.body);
images("green-visible", true);
*/


// 3Ô∏è‚É£ Inicjalizujemy obiekty na dane.
// - sources: dane wej≈õciowe z obraz√≥w
// - processed_sources: dane przetworzone
// - limit: liczba oczekiwanych ≈∫r√≥de≈Ç (dla synchronizacji)
// - corners: wsp√≥≈Çrzƒôdne rog√≥w p≈Çytki TLC
let sources = {};
let processed_sources = {};
const limit = 1;
let corners;
let mode = getString('normalisation_mode', 'unnormalise'); // 'normalise' , 'unnormalise' // INPUT* 
let data = loadFromStorage('procParams'); // obiekt przetrzymuje wszystkie modyfikowalne ustawienia

  // Definiowanie listy kluczy i callback√≥w do nas≈Çuchiwania zmian w localStorage
  window.__watchList = [
    ['procParams', (event) => { // [storage key, function for this storage key] - note not param key
        data = JSON.parse(event.newValue); // can also use explicit name
        console.log(data);
      // Mo≈ºesz np. zaktualizowaƒá UI
    }]
  ];

  // tworzy panel przycisk√≥w - link√≥w do nowych zak≈Çadek dla programu - sƒÖ otwierane w nowej zak≈ÇƒÖdce
  addCommentCell('linkButtons', 'Zak≈Çadki Pomocnicze', document.body);
  createButtonGrid([
    ['‚öôÔ∏è parametry przetwarzania', 'https://git.1ioe.top/TLC/v5/params.html'],
  ]);

// 4Ô∏è‚É£ Tworzymy panel parametr√≥w analizy.
// Funkcja parameterTable(id, tablica_parametr√≥w) generuje pola wej≈õciowe do ustawiania warto≈õci prog√≥w, symetrii itd.
// Format: [etykieta, id_parametru, domy≈õlna_warto≈õƒá]
parameterTable('parametry-progu', [
    ['‚ö†Ô∏è tryb normalizacji o≈õwietlenia (normalise / unnormalise):', 'normalisation_mode', 'unnormalise'], 
    // ‚úÖ - tego u≈ºyj dla parametr√≥w nie wymagajƒÖcych zatwiedzenia
]);

// 5Ô∏è‚É£ Tworzymy panel z przyciskami do akcji.
// Funkcja parameterButtons(id, lista_przycisk√≥w) generuje przyciski interaktywne.
// Format: [ikona/tekst, tekst pomocy, funkcja_do_uruchomienia]
// funkcje te pozwalajƒÖ na dodanie w≈Çasnej niskopoziomowej logiki
parameterButtons('panel-akcji', [
    ['üîÅüìê', 'zamie≈Ñ jednostki z pikseli na mm / mm2 i na odwr√≥t', convertTableUnits],
    ['üß™', 'Zastosuj zmianƒô parametr√≥w.', applyConfigChanges],
    ['üßπ', 'Wyczy≈õƒá dane ≈∫r√≥d≈Çowe i wyniki.', clearSources],
    ['üíæ', 'Zapisz dane na dysku.', () => alert('Zapisano!')]
]);

// 6Ô∏è‚É£ Definiujemy funkcjƒô przetwarzania ko≈Ñcowego.
function postprocess_analysis(processedData) {
    return postprocess_analysis_FULL(processedData);
}


//*********************************
// Uwaga dla AI i przysz≈Çych programist√≥w:
// - Framework ten pozwala tworzyƒá aplikacje przez opis struktury i funkcji.
// - U≈ºytkownik nie pisze niskopoziomowego kodu HTML ani event listener√≥w ‚Äì wszystko dzia≈Ça przez funkcje deklaratywne.
// - Dziƒôki temu mo≈ºna szybko stworzyƒá aplikacjƒô do analizy obraz√≥w TLC z wieloma ≈∫r√≥d≈Çami ≈õwiat≈Ça.
//*********************************


  </script>
</html>