<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QTLC v5</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>
    <script src="https://docs.opencv.org/4.7.0/opencv.js" async></script>
    <!-- warning: loading OpenCV can take some time. Load asynchronously -->
    <script src="https://cdn.jsdelivr.net/gh/ColonelParrot/jscanify@master/src/jscanify.min.js"></script>
    <script src="https://git.1ioe.top/TLC/v5/params.js"></script><!-- wej≈õcia parametr√≥w, ui dla parametr√≥w i local storage -->
    <script src="https://git.1ioe.top/TLC/v5/counting.js"></script><!-- obliczanie parametr√≥w plamek -->
    <!-- load them both always-->
    <script type="module" src="https://utils.1ioe.top/paint.js" blocking="render"></script><!-- w≈Çasny element do rysowania na canvas -->
    <script src="https://git.1ioe.top/TLC/v5/averaging.js"></script><!-- obliczanie parametr√≥w plamek -->
    <!-- load them both always-->
    <script src="https://git.1ioe.top/TLC/v5/plate.js"></script><!-- ekstrakcja i procesing p≈Çytki -->
    <script src="https://git.1ioe.top/TLC/v5/reggression.js"></script><!-- regresja wielomianowa i u≈õrednianie t≈Ça -->
    <script src="https://git.1ioe.top/TLC/v5/spots.js"></script><!-- extrakcja i preprocesing plamek -->
    <script src="https://git.1ioe.top/TLC/v5/output.js"></script><!-- tworzenie formularza z wynikami -->
    <style>
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
            height: auto;
            width: auto;
            margin: 0 auto;
            border: 1px solid #ccc; /* opcjonalnie dla widoczno≈õci */
        }
    </style>
</head>

<body class="bg-white text-dark py-4">
</body>


<script>

//################################# - funkcje do preprocess

    // funkcja do wstƒôpnego przetwarzania po za≈ÇƒÖdowaniu pierwszej p≈Çytki
    function pre_process(id, canvas, sources, processed_sources) {
        corners = assignCorners(detectBrightCorners(id, canvas));
        console.log(corners);  // 4 punkty najbli≈ºsze naro≈ºnikom
        // przetwarza w≈Ça≈õciwie ten obraz
        mid_process(id, canvas, sources, processed_sources, data);
    }

//################################# - funkcje do preprocess

//################################# - funkcje do w≈Ça≈õciwego przetwarzania

    // funkcja do w≈Ça≈õciwego przetwarzania danych:
    function mid_process(id, canvas, sources, processed_sources, processingParameters) {

        if (mode === 'normalise') { // protok√≥≈Ç uproszczony dla normalizacji fizycznej o≈õwietlenia
            addCommentCell(id+'_commentHeader', `dla obrazu: ${id}`, document.body);
            const extracted_canvas = extractDocumentFromCanvas(id, canvas);
            let boxes = extractBlobsFromCanvas(id, extracted_canvas, data); 
            boxes = maskDarkest5Percent(boxes, processingParameters.maskDarkestPercent); // INPUT*DONE (ile procent odrzuciƒá)
            processed_sources[id] = boxes;
            sources[id] = extracted_canvas;
        }
        else if (mode === 'unnormalise') { // protok√≥≈Ç dla zdjƒôƒá bez normalizacji fizycznej o≈õwietlenia
            addCommentCell(id+'_commentHeader', `dla obrazu: ${id}`, document.body);
            const extracted_canvas = extractDocumentFromCanvas_norm(id, canvas, data);
            let boxes = extractBlobsFromCanvas(id, extracted_canvas, data); 
            boxes = maskDarkest5Percent(boxes, processingParameters.maskDarkestPercent); // INPUT*DONE
            processed_sources[id] = boxes;
            sources[id] = extracted_canvas;
        }

        console.log("mid_process wywo≈Çane z sources:", id, canvas);
    }
//################################# - funkcje do w≈Ça≈õciwego przetwarzania ^ dla mid_process

//################################# - funkcje do postprocesingu

    // funkcja do ko≈Ñcowego przetwarzania danych
    function final_process(sources, processed_sources) {
        console.log("final_process wywo≈Çane z sources:", processed_sources);

        outputForm(sources, processed_sources);
    }

//################################# - funkcje do postprocesingu


//################################# - funkcje dla przycisk√≥w akcji
    
    // w≈Ça≈õciwa funkcja us√≥wania
    function removeOutputParams() {
        removeRowsWithMatchingParamsFromObject(ommitedParams);
    }

    // Usuwa wiersze zawierajƒÖce tekst bƒôdƒÖcy kluczem obiektu, kt√≥rego warto≈õƒá to false
    function removeRowsWithMatchingParamsFromObject(paramObject) {
        if (typeof paramObject !== "object" || paramObject === null || Array.isArray(paramObject)) {
            console.error("Provided argument is not a valid object.");
            return;
        }

        // Pobieramy tylko te klucze, kt√≥rych warto≈õƒá to false (czyli niechciane parametry)
        const keysToRemove = Object.keys(paramObject).filter(key => paramObject[key] === false);

        if (keysToRemove.length === 0) return;

        const rows = document.querySelectorAll("tr");
        rows.forEach(row => {
            const cells = row.querySelectorAll("td, th");
            for (const cell of cells) {
                const cellText = cell.textContent.trim();
                if (keysToRemove.includes(cellText)) {
                    row.remove();
                    break;
                }
            }
        });
    }


    // zmienia parametry wymagajƒÖce zmiany
    function applyConfigChanges(){
        mode = getString('normalisation_mode', 'unnormalise'); // 'normalise' , 'unnormalise' // 
    }
    // czy≈õci dane przetworzone
    function clearSources() {
        sources = {};
        processed_sources = {};
        alert('Dane ≈∫r√≥d≈Çowe i wyniki zosta≈Çy wyczyszczone.');
    }


    function convertTableUnits() { // do wyrzucenia
        // przyjmujemy, ≈ºe 1 px przypada na d≈Çugo≈õƒá boku p≈Çtyki
        // przyjmujemy, ≈ºe p≈Çytka ma 10 cm

        const keyWords_mm2 = [ 'spotSurface'];
        const keyWords_mm = ['x', 'y', 'width', 'height', 'yB01', 'yA01', 'xB01', 'xA01', 'yB005', 'yA005', 'xB005', 'xA005', 
            'yW0', 'xW0', 'yW005', 'xW005', 'yW01', 'xW01', 'yW05', 'xW05', 'yPeakonTrack', 'xPeakonTrack',
            'yTrackWidth', 'xTrackWidth', 'endLineY', 'startLineY', 'endLineX', 'startLineX', 'maxY', 'maxX'
         ];
        const allTables = document.querySelectorAll("table");

        allTables.forEach(table => {
            const rows = table.querySelectorAll("tr");
            rows.forEach(row => {
                const cells = row.querySelectorAll("td, th");
                if (cells.length < 2) return;

                const label = cells[0].innerText.trim();
                const valueCell = cells[1];

                const text = valueCell.innerText.trim();

                // Dopasuj liczby i jednostki
                const match = text.match(/^([0-9.,]+)\s*(mm¬≤|mm)?$/i);
                if (!match) return;

                let number = parseFloat(match[1].replace(",", "."));
                const unit = match[2]?.toLowerCase();

                if (keyWords_mm2.includes(label)) {
                    if (!unit) {
                        // Bez jednostki, liczba w px¬≤ ‚Üí przelicz na mm¬≤
                        number = number * 0.01;
                        valueCell.innerText = number.toFixed(2) + " mm¬≤";
                    } else if (unit === 'mm¬≤') {
                        // Jest mm¬≤ ‚Üí przelicz na px¬≤
                        number = number / 0.01;
                        valueCell.innerText = Math.round(number); // bez jednostki
                    }
                } else if (keyWords_mm.includes(label)) {
                    if (!unit) {
                        // Bez jednostki, liczba w px ‚Üí przelicz na mm
                        number = number * 0.1;
                        valueCell.innerText = number.toFixed(2) + " mm";
                    } else if (unit === 'mm') {
                        // Jest mm ‚Üí przelicz na px
                        number = number / 0.1;
                        valueCell.innerText = Math.round(number); // bez jednostki
                    }
                }
            });
        });
    }
//################################# - funkcje dla przycisk√≥w akcji


//################################# - funkcje do definiowania przep≈Çywu pracy

    // funkcja obs≈ÇugujƒÖca kolejno≈õƒá przep≈Çywu przetwarzania
    function handleCanvasInput(canvas, id, sources, processed_sources, limit) {
        const currentSize = Object.keys(sources).length;

        // Zapisz canvas do sources
        sources[id] = canvas;

        if (limit <= 0) {
            console.warn("Niepoprawna warto≈õƒá limitu:", limit);
            return;
        }

        if (limit === 1) {
            pre_process(id, canvas, sources, processed_sources);
            final_process(sources, processed_sources);
        } else if (limit === 2) {
            if (currentSize === 0) {
                pre_process(id, canvas, sources, processed_sources);
            } else if (currentSize === 1) {
                mid_process(id, canvas, sources, processed_sources, data);
                final_process(sources, processed_sources);
            }
        } else { // limit >= 3
            if (currentSize === 0) {
                pre_process(id, canvas, sources, processed_sources);
            } else if (currentSize < limit - 1) {
                mid_process(id, canvas, sources, processed_sources, data);
            } else if (currentSize === limit - 1) {
                mid_process(id, canvas, sources, processed_sources, data);
                final_process(sources, processed_sources);
            }
        }
    }


    // wywo≈Çywany po ka≈ºdym za≈Çadowaniu ew. u≈õrednieniu obrazu
    window.addEventListener('newScan', (e) => {
        handleCanvasInput(e.detail.canvas, e.detail.id, sources, processed_sources, limit);
    });

//################################# - funkcje do definiowania przep≈Çywu pracy    

//*********************************
// Przyk≈Çad aplikacji TLC w frameworku low-code (JavaScript)
// Autor: [Twoje Imiƒô]
// Cel: Analiza TLC na podstawie 3 obraz√≥w ‚Äì UV 254 nm, UV 365 nm i ≈õwiat≈Ço zielone
// Ten kod tworzy aplikacjƒô za pomocƒÖ gotowych funkcji wysokiego poziomu.
//*********************************

// üü© Komentarze opisujƒÖ ka≈ºdƒÖ sekcjƒô zrozumiale dla cz≈Çowieka i AI.

// 1Ô∏è‚É£ Dodajemy komentarze/etykiety opisujƒÖce kolejne sekcje aplikacji.
// Funkcja addCommentCell(id, tekst, element_docelowy) dodaje komentarz HTML do interfejsu.

// 2Ô∏è‚É£ Dodajemy panele do ≈Çadowania obraz√≥w dla 3 r√≥≈ºnych ≈∫r√≥de≈Ç.
// Funkcja images(id, trigger) tworzy panel ≈Çadowania obraz√≥w.
// - id: unikalny identyfikator
// - trigger: true = uruchom przetwarzanie automatycznie po za≈Çadowaniu
addCommentCell('comment-1', 'Za≈Çaduj obraz dla UV 254 nm', document.body);
images("uv-254", true);

// i powtarzamy schemat

/*
addCommentCell('comment-2', 'Za≈Çaduj obraz dla UV 365 nm', document.body);
images("uv-365", true);

addCommentCell('comment-3', 'Za≈Çaduj obraz w ≈õwietle zielonym (widzialnym)', document.body);
images("green-visible", true);
*/


// 3Ô∏è‚É£ Inicjalizujemy obiekty na dane.
// - sources: dane wej≈õciowe z obraz√≥w
// - processed_sources: dane przetworzone
// - limit: liczba oczekiwanych ≈∫r√≥de≈Ç (dla synchronizacji)
// - corners: wsp√≥≈Çrzƒôdne rog√≥w p≈Çytki TLC
let sources = {};
let processed_sources = {};
const limit = 1;
let corners;
let mode = getString('normalisation_mode', 'unnormalise'); // 'normalise' , 'unnormalise' 
let data = loadFromStorage('procParams'); // obiekt przetrzymuje wszystkie modyfikowalne ustawienia
let ommitedParams = loadFromStorage('countedParams'); // obiekt przetrzymuje wszystkie modyfikowalne ustawienia

  // Definiowanie listy kluczy i callback√≥w do nas≈Çuchiwania zmian w localStorage
  window.__watchList = [
    ['procParams', (event) => { // [storage key, function for this storage key] - note not param key
        data = JSON.parse(event.newValue); // can also use explicit name
        console.log(data);
      // Mo≈ºesz np. zaktualizowaƒá UI
    }],
    ['countedParams', (event) => {
        ommitedParams = JSON.parse(event.newValue); // can also use explicit name
        console.log(ommitedParams);
      // Mo≈ºesz np. zaktualizowaƒá UI
    }]
  ];

  // tworzy panel przycisk√≥w - link√≥w do nowych zak≈Çadek dla programu - sƒÖ otwierane w nowej zak≈ÇƒÖdce
  addCommentCell('linkButtons', 'Zak≈Çadki Pomocnicze', document.body);
  createButtonGrid([
    ['‚öôÔ∏è parametry przetwarzania', 'https://git.1ioe.top/TLC/v5/params.html'],
    ['‚öôÔ∏è parametry wyliczane', 'https://git.1ioe.top/TLC/v5/countedParams.html'],
  ]);

// 4Ô∏è‚É£ Tworzymy panel parametr√≥w analizy.
// Funkcja parameterTable(id, tablica_parametr√≥w) generuje pola wej≈õciowe do ustawiania warto≈õci prog√≥w, symetrii itd.
// Format: [etykieta, id_parametru, domy≈õlna_warto≈õƒá]
parameterTable('parametry-progu', [
    ['‚ö†Ô∏è tryb normalizacji o≈õwietlenia (normalise / unnormalise):', 'normalisation_mode', 'unnormalise'], 
    // ‚úÖ - tego u≈ºyj dla parametr√≥w nie wymagajƒÖcych zatwiedzenia
]);

// 5Ô∏è‚É£ Tworzymy panel z przyciskami do akcji.
// Funkcja parameterButtons(id, lista_przycisk√≥w) generuje przyciski interaktywne.
// Format: [ikona/tekst, tekst pomocy, funkcja_do_uruchomienia]
// funkcje te pozwalajƒÖ na dodanie w≈Çasnej niskopoziomowej logiki
parameterButtons('panel-akcji', [
    ['üîÅüìê', 'zamie≈Ñ jednostki z pikseli na mm / mm2 i na odwr√≥t', convertTableUnits],
    ['üß™', 'Zastosuj zmianƒô kluczowych parametr√≥w, oznaczonych symbolem: "‚ö†Ô∏è".', applyConfigChanges],
    ['üßπ', 'Wyczy≈õƒá wyniki po≈õrednie, aby dodaƒá nowe obazy do przetwarzania. za≈Çadowanie ponowne zdjƒôƒá bez klikniƒôcia tego przycisku mo≈ºe niekiedy nie rozpoczƒÖƒá automatycznie kolejki przetwarzania.', clearSources],
    ['üíæ', 'Zapisz dane na dysku.', () => window.print()],
    ['üßπüìê', 'Usu≈Ñ niechciane wyniki.', removeOutputParams],
]);

// 6Ô∏è‚É£ Definiujemy funkcjƒô przetwarzania ko≈Ñcowego.
function postprocess_analysis(processedData) {
    return postprocess_analysis_FULL(processedData, data);
}


//*********************************
// Uwaga dla AI i przysz≈Çych programist√≥w:
// - Framework ten pozwala tworzyƒá aplikacje przez opis struktury i funkcji.
// - U≈ºytkownik nie pisze niskopoziomowego kodu HTML ani event listener√≥w ‚Äì wszystko dzia≈Ça przez funkcje deklaratywne.
// - Dziƒôki temu mo≈ºna szybko stworzyƒá aplikacjƒô do analizy obraz√≥w TLC z wieloma ≈∫r√≥d≈Çami ≈õwiat≈Ça.
//*********************************


  </script>
</html>