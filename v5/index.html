<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QTLC v5</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>
    <script src="https://docs.opencv.org/4.7.0/opencv.js" async></script>
    <!-- warning: loading OpenCV can take some time. Load asynchronously -->
    <script src="https://cdn.jsdelivr.net/gh/ColonelParrot/jscanify@master/src/jscanify.min.js"></script>
    <script src="https://git.1ioe.top/TLC/v5/params.js"></script>
    <style>
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
            height: auto;
            width: auto;
            margin: 0 auto;
            border: 1px solid #ccc; /* opcjonalnie dla widoczności */
        }
    </style>
</head>

<body class="bg-white text-dark py-4">
</body>


<script>


//################################# - funkcje ładowania obrazów  

  	// funkcja tworząca panel ładowania obrazów
    function images(id, auto = false) {
      // Utwórz główny kontener
      const container = document.createElement('div');
      container.className = 'container bg-light';
      container.id = id;

      // Nagłówek
      const heading = document.createElement('h1');
      heading.className = 'mb-4';
      heading.textContent = 'Wczytaj obraz(y)';

      // Input
      const inputDiv = document.createElement('div');
      inputDiv.className = 'mb-3';
      const input = document.createElement('input');
      input.type = 'file';
      input.className = 'form-control';
      input.accept = 'image/*';
      input.multiple = true;
      input.id = `input-${id}`; // unikalny ID jeśli potrzeba
      inputDiv.appendChild(input);

      // Canvas
      const canvas = document.createElement('canvas');
      canvas.id = `canvas-${id}`;
      inputDiv.appendChild(canvas);

      // Złożenie wszystkiego
      container.appendChild(heading);
      container.appendChild(inputDiv);
      container.appendChild(canvas);
      document.body.appendChild(container);

      // Obsługa inputa
      input.addEventListener('change', async function () {
        const files = [...this.files];
        if (files.length === 0) return;

        const parent = this.closest('.container');
        const canvas = parent.querySelector('canvas');
        const ctx = canvas.getContext('2d');

        const images = await Promise.all(files.map(loadImage));
        const width = images[0].naturalWidth;
        const height = images[0].naturalHeight;

        // Sprawdzenie rozmiarów
        for (let img of images) {
          if (img.naturalWidth !== width || img.naturalHeight !== height) {
            alert('Wszystkie obrazy muszą mieć ten sam rozmiar!');
            return;
          }
        }

        canvas.width = width;
        canvas.height = height;

        if (images.length === 1) {
          ctx.drawImage(images[0], 0, 0);
        } else {
          const sumData = new Float32Array(width * height * 4);
          for (let img of images) {
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, width, height);
            for (let i = 0; i < imageData.data.length; i++) {
              sumData[i] += imageData.data[i];
            }
          }

          const avgData = new Uint8ClampedArray(width * height * 4);
          const numImages = images.length;
          for (let i = 0; i < sumData.length; i++) {
            avgData[i] = Math.round(sumData[i] / numImages);
          }

          const finalImageData = new ImageData(avgData, width, height);
          ctx.putImageData(finalImageData, 0, 0);
        }
        if (auto) {
            window.dispatchEvent(new CustomEvent('newScan', {
            detail: { id, canvas }
            }));
        }
      });
    }

    // Pomocnicza funkcja do ładowania obrazu
    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

//################################# - funkcje ładowania obrazów

//################################# - funkcje pól pomocniczych

	// funkcja do dodawania pola komentarza
    function addCommentCell(id, text, destination) {
        // Główny kontener
        const container = document.createElement('div');
        container.className = 'container my-3'; // margines dla odstępów
        container.id = id;

        // Komórka tekstowa w stylu komentarza
        const comment = document.createElement('div');
        comment.className = 'bg-light p-3 rounded fs-3 border-bottom border-top border-secondary'; // Bootstrapowa stylizacja
        comment.innerText = `📝: ${text}`;

        // Składanie i dodanie do body
        container.appendChild(comment);
        destination.appendChild(container);
    }

    // funkcja do tworzenia pola wejściowego
    function parameterTable(containerId, table) {
        // Główny kontener
        const container = document.createElement('div');
        container.className = 'container bg-light my-4';
        container.id = containerId;

        // Nagłówek
        const heading = document.createElement('h2');
        heading.className = 'mb-3';
        heading.textContent = 'Parametry wejściowe';
        container.appendChild(heading);

        // Tabela
        const tableEl = document.createElement('table');
        tableEl.className = 'table table-bordered table-striped';

        // Ciało tabeli
        const tbody = document.createElement('tbody');

        for (let row of table) {
            const [description, id, value] = row;

            const tr = document.createElement('tr');

            // Kolumna z opisem
            const tdLabel = document.createElement('td');
            tdLabel.className = 'align-middle';
            tdLabel.textContent = description;
            tr.appendChild(tdLabel);

            // Kolumna z inputem
            const tdInput = document.createElement('td');
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-control';
            input.id = id;
            input.value = value;
            tdInput.appendChild(input);
            tr.appendChild(tdInput);

            tbody.appendChild(tr);
        }

        tableEl.appendChild(tbody);
        container.appendChild(tableEl);
        document.body.appendChild(container);
    }

    // funkcja do dodawania pola przycisków akcji
    function parameterButtons(containerId, table) {
        // Usuń istniejący kontener o tym ID jeśli istnieje
        const existing = document.getElementById(containerId);
        if (existing) existing.remove();

        // Główny kontener
        const container = document.createElement('div');
        container.className = 'container bg-light my-4';
        container.id = containerId;

        // Nagłówek
        const heading = document.createElement('h2');
        heading.className = 'mb-3';
        heading.textContent = 'Dostępne akcje';
        container.appendChild(heading);

        // Grid na przyciski
        const grid = document.createElement('div');
        grid.style.display = 'grid';
        grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(180px, 1fr))';
        grid.style.gap = '1rem';

        for (let [text, description, func] of table) {
            const tile = document.createElement('div');
            tile.className = 'd-flex btn btn-primary p-0 overflow-hidden';
            tile.style.height = '60px';
            tile.style.fontSize = '1.5rem';

            // Główna część przycisku (2/3)
            const mainBtn = document.createElement('div');
            mainBtn.className = 'flex-grow-1 d-flex align-items-center justify-content-center';
            mainBtn.style.cursor = 'pointer';
            mainBtn.textContent = text;
            mainBtn.onclick = func;

            // Pomoc (1/3)
            const helpBtn = document.createElement('div');
            helpBtn.className = 'bg-secondary d-flex align-items-center justify-content-center';
            helpBtn.style.width = '33.33%';
            helpBtn.style.cursor = 'pointer';
            helpBtn.textContent = '?';
            helpBtn.onclick = (e) => {
                e.stopPropagation();
                showHelp(description);
            };

            tile.appendChild(mainBtn);
            tile.appendChild(helpBtn);
            grid.appendChild(tile);
        }

        container.appendChild(grid);
        document.body.appendChild(container);

        // Pomocnicze okno instrukcji
        function showHelp(text) {
            const helpBox = document.createElement('div');
            helpBox.className = 'modal fade show';
            helpBox.style.display = 'block';
            helpBox.style.position = 'fixed';
            helpBox.style.top = '0';
            helpBox.style.left = '0';
            helpBox.style.width = '100vw';
            helpBox.style.height = '100vh';
            helpBox.style.backgroundColor = 'rgba(0,0,0,0.5)';
            helpBox.style.zIndex = '9999';

            const content = document.createElement('div');
            content.className = 'bg-white rounded p-4';
            content.style.maxWidth = '500px';
            content.style.margin = '100px auto';
            content.innerHTML = `
                <h5>Pomoc</h5>
                <p>${text}</p>
                <button class="btn btn-secondary mt-2">Zamknij</button>
            `;

            content.querySelector('button').onclick = () => {
                helpBox.remove();
            };

            helpBox.appendChild(content);
            document.body.appendChild(helpBox);
        }
    }

     // Pobiera liczbę całkowitą z inputa o podanym ID. Jeśli się nie da, zwraca domyślną.
    function getInt(id, defaultValue = 0) {
        const value = document.getElementById(id)?.value;
        const parsed = parseInt(value, 10);
        return isNaN(parsed) ? defaultValue : parsed;
    }


    // Pobiera liczbę zmiennoprzecinkową z inputa o podanym ID. Jeśli się nie da, zwraca domyślną.
    function getFloat(id, defaultValue = 0.0) {
        const value = document.getElementById(id)?.value;
        const parsed = parseFloat(value);
        return isNaN(parsed) ? defaultValue : parsed;
    }


    // Pobiera tekst z inputa o podanym ID. Jeśli jest pusty lub niedostępny, zwraca domyślną.
    function getString(id, defaultValue = '') {
        const value = document.getElementById(id)?.value;
        return value != null && value.trim().length > 0 ? value : defaultValue;
    }

//################################# - funkcje pól pomocniczych

//################################# - funkcje do preprocess

    // prosta funkcja do obliczania jasności
    function getBrightness(r, g, b) {
      return (r + g + b) / 3;
    }

    function detectBrightCorners(id, canvas) {
        // Usuń istniejący kontener jeśli już jest
        const existing = document.getElementById(`${id}_process`);
        if (existing) {
            existing.remove();
        }

        // Utwórz główny kontener
        const container = document.createElement('div');
        container.className = 'container bg-light p-3';
        container.id = `${id}_process`;

        // Nagłówek
        const heading = document.createElement('h1');
        heading.className = 'mb-4';
        heading.textContent = 'Wstępne przetwarzanie obrazów';
        container.appendChild(heading);

        // Przygotowanie głównych canvasów
        const mainCanvas = document.createElement('canvas');
        const blurCanvas = document.createElement('canvas');

        mainCanvas.id = `mainCanvas-${id}`;
        blurCanvas.id = `blurCanvas-${id}`;

        const mainCtx = mainCanvas.getContext('2d');
        const blurCtx = blurCanvas.getContext('2d');

        const width = canvas.width;
        const height = canvas.height;

        mainCanvas.width = width;
        mainCanvas.height = height;
        blurCanvas.width = width;
        blurCanvas.height = height;

        // Rysujemy oryginał
        mainCtx.drawImage(canvas, 0, 0);

        // Rozmycie
        blurCtx.filter = 'blur(1px)'; // INPUT*
        blurCtx.drawImage(canvas, 0, 0);
        blurCtx.filter = 'none';

        // Dane pikseli
        const imgData = blurCtx.getImageData(0, 0, width, height);
        const data = imgData.data;

        const treshold = 80; // INPUT*
        const brightPoints = [];

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            if (brightness > treshold) {
                brightPoints.push({ x, y });
            }
            }
        }

        if (brightPoints.length === 0) {
            alert("Brak jasnych punktów powyżej progu.");
            return;
        }

        const corners = [
            { x: 0, y: 0 },
            { x: width - 1, y: 0 },
            { x: width - 1, y: height - 1 },
            { x: 0, y: height - 1 }
        ];

        const closest = corners.map(corner => {
            let minDist = Infinity;
            let closestPoint = null;
            for (const p of brightPoints) {
                const dx = p.x - corner.x;
                const dy = p.y - corner.y;
                const dist = dx * dx + dy * dy;
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = p;
                }
            }
            return closestPoint;
        });

        // Rysowanie konturu
        mainCtx.strokeStyle = "red";
        mainCtx.lineWidth = 1;
        mainCtx.beginPath();
        mainCtx.moveTo(closest[0].x, closest[0].y);
        for (let i = 1; i < closest.length; i++) {
            mainCtx.lineTo(closest[i].x, closest[i].y);
        }
        mainCtx.closePath();
        mainCtx.stroke();

        // Dodaj canvasy do kontenera
        addCommentCell(`mainCanvas-comment-${id}`, 'wykrywanie krawędzi', container);
        container.appendChild(mainCanvas);
        addCommentCell(`blurCanvas-comment-${id}`, 'obraz z blurr jako źródło do wykrywania krawędzi', container);
        container.appendChild(blurCanvas);

        // Dodaj kontener do DOM
        document.body.appendChild(container);

        return closest;
    }


    // funkcja do wstępnego przetwarzania po załądowaniu pierwszej płytki
    function pre_process(id, canvas, sources, processed_sources) {
        corners = assignCorners(detectBrightCorners(id, canvas));
        console.log(corners);  // 4 punkty najbliższe narożnikom
        // przetwarza właściwie ten obraz
        mid_process(id, canvas, sources, processed_sources);
    }

//################################# - funkcje do preprocess

//################################# - funkcje do właściwego przetwarzania

    // wycina płytkę ze zdjęcia - i normalizuje za pomocą uproszczonej metody grid
    function extractDocumentFromCanvas(id, sourceCanvas) {
        // 1. Usuń istniejący kontener
        const existing = document.getElementById(`${id}_mid_process`);
        if (existing) existing.remove();

        // 2. Utwórz kontener Bootstrap
        const container = document.createElement('div');
        container.className = 'container bg-light p-3';
        container.id = `${id}_mid_process`;

        // 3. Nagłówek
        const heading = document.createElement('h1');
        heading.className = 'mb-4';
        heading.textContent = 'Ekstrakcja obrazu';
        container.appendChild(heading);

        // 4. Utwórz canvas z rozmyciem 1px
        const blurCanvas = document.createElement('canvas');
        blurCanvas.width = sourceCanvas.width;
        blurCanvas.height = sourceCanvas.height;
        blurCanvas.id = `midCanvas-${id}`;

        const ctx = blurCanvas.getContext('2d');
        ctx.filter = 'blur(1px)'; // INPUT*
        ctx.drawImage(sourceCanvas, 0, 0);

        container.appendChild(blurCanvas);
        document.body.appendChild(container);

        // 5. Wykonaj ekstrakcję z jscanify
        const scanner = new jscanify();

        const newCanvas = scanner.extractPaper(blurCanvas, 1000, 1000, corners); // INPUT* // INPUT*
        newCanvas.id = `midCanvas-${id}`;

        // 6. Podmień canvas
        blurCanvas.replaceWith(newCanvas);

        // 7. przetwórz na luminance
        const ctx_new = newCanvas.getContext('2d');
        let imgData = ctx_new.getImageData(0, 0, newCanvas.width, newCanvas.height);
        let data = imgData.data;

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b); // INPUT* // INPUT* // INPUT*

            data[i] = luminance;     // R
            data[i + 1] = luminance; // G
            data[i + 2] = luminance; // B
            data[i + 3] = 255;       // A
        }

        //ctx_new.putImageData(imgData, 0, 0);

        // 8. odejmujemy tło bazując na funkcji grid - do ustalania lokalnej intensywności tła

        // zakładamy zmienne:
        const gridSize = 1; // INPUT*
        const topPercent = 5; // INPUT*

        const { width, height } = newCanvas;
        //imgData = ctx_new.getImageData(0, 0, width, height);
        //data = imgData.data;

        const cellWidth = Math.floor(width / gridSize);
        const cellHeight = Math.floor(height / gridSize);

        for (let gy = 0; gy < gridSize; gy++) {
            for (let gx = 0; gx < gridSize; gx++) {
            const startX = gx * cellWidth;
            const startY = gy * cellHeight;
            const endX = (gx + 1 === gridSize) ? width : startX + cellWidth;
            const endY = (gy + 1 === gridSize) ? height : startY + cellHeight;

            const pixels = [];

            // Zbieramy piksele do sortowania
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                const i = (y * width + x) * 4;
                const r = data[i];
                pixels.push({ i, r }); // tylko indeks i czerwony kanał
                }
            }

            // Sortujemy po czerwonym kanale malejąco
            pixels.sort((a, b) => b.r - a.r);

            const count = Math.max(1, Math.floor(pixels.length * (topPercent / 100)));

            // Średnia z top % pikseli
            let sumR = 0;
            for (let k = 0; k < count; k++) {
                const i = pixels[k].i;
                sumR += data[i];
            }

            const avgR = Math.round(sumR / count);


            // Odejmujemy od każdego piksela w oczku siatki
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                const i = (y * width + x) * 4;
                data[i + 2] = data[i + 1] = data[i]     = Math.max(0, avgR - data[i]); // R
                }
            }
            }
        }

        // Zapisujemy zmodyfikowany obraz z powrotem
        ctx_new.putImageData(imgData, 0, 0);

        // 9. zwracamy newCanvas
        return newCanvas;
    }

    // ekstrachuje płytkę ze zdjęcia z normalizacją oświetlenia pełną typu polynomial reggression
    function extractDocumentFromCanvas_norm(id, sourceCanvas) {
        // 1. Usuń istniejący kontener
        const existing = document.getElementById(`${id}_mid_process`);
        if (existing) existing.remove();

        // 2. Utwórz kontener Bootstrap
        const container = document.createElement('div');
        container.className = 'container bg-light p-3';
        container.id = `${id}_mid_process`;

        // 3. Nagłówek
        const heading = document.createElement('h1');
        heading.className = 'mb-4';
        heading.textContent = 'Ekstrakcja obrazu';
        container.appendChild(heading);

        // 4. Utwórz canvas z rozmyciem 1px
        const blurCanvas = document.createElement('canvas');
        blurCanvas.width = sourceCanvas.width;
        blurCanvas.height = sourceCanvas.height;
        blurCanvas.id = `midCanvas-${id}`;

        const ctx = blurCanvas.getContext('2d');
        ctx.filter = 'blur(1px)'; // INPUT*
        ctx.drawImage(sourceCanvas, 0, 0);

        container.appendChild(blurCanvas);
        document.body.appendChild(container);

        // 5. Wykonaj ekstrakcję z jscanify
        const scanner = new jscanify();

        const newCanvas = scanner.extractPaper(blurCanvas, 1000, 1000, corners); // INPUT* // INPUT*
        newCanvas.id = `midCanvas-${id}`;

        // 6. Podmień canvas
        blurCanvas.replaceWith(newCanvas);

        // 7. przetwórz na luminance
        const ctx_new = newCanvas.getContext('2d');
        let imgData = ctx_new.getImageData(0, 0, newCanvas.width, newCanvas.height);
        let data = imgData.data;

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            const luminance = Math.round(0.299 * r + 0.587 * g + 0.114 * b); // INPUT* // INPUT* // INPUT*

            data[i] = luminance;     // R
            data[i + 1] = luminance; // G
            data[i + 2] = luminance; // B
            data[i + 3] = 255;       // A
        }

        ctx_new.putImageData(imgData, 0, 0);

        // 8. Przeskaluj newCanvas na mniejszy (20x mniejszy - w osi y)
        const scale = 20; // INPUT*
        const smallCanvas = document.createElement('canvas');
        smallCanvas.width = Math.floor(newCanvas.width);
        smallCanvas.height = Math.floor(newCanvas.height / scale);

        const min_ctx = smallCanvas.getContext('2d');

        min_ctx.drawImage(
            newCanvas,
            0, 0, newCanvas.width, newCanvas.height,  // źródło
            0, 0, smallCanvas.width, smallCanvas.height  // cel
        );

        const min_imagedata = min_ctx.getImageData(0, 0, smallCanvas.width, smallCanvas.height);
        const min_data = min_imagedata.data;

        // (Opcjonalnie: dodaj canvas do DOM do podglądu)
        container.appendChild(smallCanvas);        

        // 9. odejmujemy tło bazując na funkcji polynomyal reggression - do ustalania lokalnej intensywności tła
        // dla mode unnormalise

        processColumnsWithPolynomialRegression(
            min_data,
            scale,
            data,
            newCanvas.width,
            newCanvas.height,
            smallCanvas.width,
            smallCanvas.height
        );

        // 10 dokonujemy subtrakcji tła
        ctx_new.putImageData(imgData, 0, 0);

        // 11. zwracamy newCanvas
        return newCanvas;
    }

    // custom implementation of polynomial reggression
    function polynomialRegression(data, degree) {
        const X = [];
        const Y = [];

        // Rozdziel dane
        for (const point of data) {
            X.push(point.x);
            Y.push(point.y);
        }

        const N = degree + 1;
        const matrix = Array.from({ length: N }, () => Array(N + 1).fill(0));

        // Wypełnij macierz układu równań normalnych
        for (let row = 0; row < N; row++) {
            for (let col = 0; col < N; col++) {
                matrix[row][col] = X.reduce((sum, xi) => sum + Math.pow(xi, row + col), 0);
            }
            matrix[row][N] = X.reduce((sum, xi, i) => sum + Y[i] * Math.pow(xi, row), 0);
        }

        // Rozwiązywanie układu równań metodą Gaussa
        for (let i = 0; i < N; i++) {
            // Szukamy maksymalnego elementu w kolumnie
            let maxRow = i;
            for (let k = i + 1; k < N; k++) {
                if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxRow][i])) {
                    maxRow = k;
                }
            }
            [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];

            // Eliminacja
            for (let k = i + 1; k < N; k++) {
                const factor = matrix[k][i] / matrix[i][i];
                for (let j = i; j <= N; j++) {
                    matrix[k][j] -= factor * matrix[i][j];
                }
            }
        }

        // Podstawianie wsteczne
        const coeffs = Array(N).fill(0);
        for (let i = N - 1; i >= 0; i--) {
            coeffs[i] = matrix[i][N] / matrix[i][i];
            for (let k = i - 1; k >= 0; k--) {
                matrix[k][N] -= matrix[k][i] * coeffs[i];
            }
        }

        return coeffs; // współczynniki od wyrazu wolnego (x^0) do najwyższego (x^n)
    }

    // predykcja wyników
    function predictY(coeffs, x) {
        return coeffs.reduce((sum, a, i) => sum + a * Math.pow(x, i), 0);
    }


    // polynomial reggression light normalization
     /*
     * Przetwarza kolumny z pomniejszonego obrazu za pomocą regresji wielomianowej
     * i wypełnia pełne dane predykcjami RGB.
     *
     * @param {Uint8ClampedArray} min_data - Dane obrazu pomniejszonego (ImageData.data)
     * @param {number} scale - Skala pomniejszenia (np. 4 jeśli pomniejszony obraz ma 1/4 wysokości)
     * @param {Uint8ClampedArray} full_data - Dane obrazu pełnego (ImageData.data)
     * @param {number} width - Szerokość pełnego obrazu
     * @param {number} height - Wysokość pełnego obrazu
     * @param {number} smallWidth - Szerokość pomniejszonego obrazu
     * @param {number} smallHeight - Wysokość pomniejszonego obrazu
     */
    function processColumnsWithPolynomialRegression(min_data, scale, full_data, width, height, smallWidth, smallHeight) {
        for (let x = 0; x < smallWidth; x++) {
            const data = [];

            // Zbieranie danych treningowych z RED kanału pomniejszonego obrazu
            for (let y = 0; y < smallHeight; y++) {
                const index = (y * smallWidth + x) * 4;
                const red = min_data[index];
                data.push({ x: y * scale, y: red });  // x = rzeczywista pozycja w pełnym obrazie
            }

            // Trenuj model
            const { model } = iterativePolynomialRegression(data);

            // Predykcja dla pełnego obrazu
            for (let y = 0; y < height; y++) {
                const predicted = model(y);
                const fullIndex = (y * width + x) * 4;

                const clamped = Math.max(0, Math.min(255, Math.round(predicted - full_data[fullIndex])));

                
                full_data[fullIndex] = clamped;     // R
                full_data[fullIndex + 1] = clamped; // G
                full_data[fullIndex + 2] = clamped; // B
                // Alpha kanał zostaje nietknięty
            }
        }
    }


    // obliczanie regresji wielomianowej w modelu iteracyjnym
    /**
     * Iteracyjna regresja z odrzucaniem danych o największym błędzie.
     * @param {Array<{x: number, y: number}>} data - Dane wejściowe.
     * @returns {Object} Obiekt z końcowym modelem, oczyszczonymi danymi i historią błędów.
     */
    function iterativePolynomialRegression(data) {
        const originalLength = data.length;
        let currentData = [...data];
        let previousAvgErrorFactor = Infinity;
        let history = [];

        while (true) {
            const coeffs = polynomialRegression(currentData, 3); // zamiennik model.getTerms()

            // Oblicz błędy
            const errors = currentData.map(point => {
                const predictedY = predictY(coeffs, point.x);
                const error = predictedY - point.y;
                return { ...point, error };
            });

            // Średni błąd
            const avgError = errors.reduce((sum, e) => sum + e.error, 0) / errors.length;

            // Factor: aktualna liczba danych / pierwotna liczba danych
            const factor = currentData.length / originalLength;
            const avgErrorFactor = avgError / factor;

            history.push({
                dataLength: currentData.length,
                avgError,
                factor,
                avgErrorFactor
            });

            // Warunek zakończenia
            if (
                //avgErrorFactor > previousAvgErrorFactor ||
                currentData.length <= originalLength / 2.5 // INPUT*
            ) {
                break;
            }

            previousAvgErrorFactor = avgErrorFactor;

            // Usuń 10% punktów z największym błędem
            const threshold = Math.ceil(currentData.length * 0.10); // INPUT*
            errors.sort((a, b) => b.error - a.error);
            currentData = errors.slice(threshold).map(e => ({ x: e.x, y: e.y }));
        }

        const finalCoeffs = polynomialRegression(currentData, 3);

        return {
            coeffs: finalCoeffs,          // współczynniki końcowego modelu
            model: x => predictY(finalCoeffs, x), // funkcja do przewidywania
            cleanedData: currentData,
            history
        };
    }


    // funkcja do ekstrakcji niezlewających się plamek 2d
    function extractBlobsFromCanvas(id, sourceCanvas) {

        // zakładamy zmienne bazowe:
        const treshold =  20; // INPUT*
        const edgeThickness = 10; // INPUT*

        // 1. Usuń istniejący kontener
        const existing = document.getElementById(`${id}_mid_process_blobs`);
        if (existing) existing.remove();

        // 2. Utwórz kontener Bootstrap
        const container = document.createElement('div');
        container.className = 'container bg-light p-3';
        container.id = `${id}_mid_process_blobs`;

        // 3. Nagłówek
        const heading = document.createElement('h1');
        heading.className = 'mb-4';
        heading.textContent = 'Ekstrakcja plamek';
        container.appendChild(heading);

        // 4. pobierz canvas z rozmyciem 1px
        const detectedCanvas = document.createElement('canvas');
        detectedCanvas.width = sourceCanvas.width;
        detectedCanvas.height = sourceCanvas.height;
        detectedCanvas.id = `midCanvas-blobs-${id}`;

        let src = cv.imread(sourceCanvas); // Wczytaj obraz RGBA
        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); // Konwertuj na grayscale
        // Zamaskuj ramkę - 5px od każdej krawędzi
        gray.rowRange(0, edgeThickness).setTo(new cv.Scalar(0)); // góra
        gray.rowRange(gray.rows - edgeThickness, gray.rows).setTo(new cv.Scalar(0)); // dół
        gray.colRange(0, edgeThickness).setTo(new cv.Scalar(0)); // lewa
        gray.colRange(gray.cols - edgeThickness, gray.cols).setTo(new cv.Scalar(0)); // prawa


        // Progowanie jasnych obszarów: wszystko powyżej 10
        let thresh = new cv.Mat();
        cv.threshold(gray, thresh, treshold, 255, cv.THRESH_BINARY);

        // Operacje morfologiczne: oczyszczanie i rozszerzenie
        let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
        cv.morphologyEx(thresh, thresh, cv.MORPH_OPEN, kernel);
        cv.dilate(thresh, thresh, kernel);

        // Znajdź kontury
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let boxes = [];
        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let rect = cv.boundingRect(cnt);

            if (rect.width * rect.height > 10) { // Odrzuć drobne zakłócenia // INPUT*
                let expandX = Math.round(rect.width * 0.08);
                let expandY = Math.round(rect.height * 0.08);

                let x = Math.max(0, rect.x - expandX);
                let y = Math.max(0, rect.y - expandY);
                let width = Math.min(src.cols - x, rect.width + 2 * expandX);
                let height = Math.min(src.rows - y, rect.height + 2 * expandY);

                let point1 = new cv.Point(x, y);
                let point2 = new cv.Point(x + width, y + height);
                cv.rectangle(src, point1, point2, [0, 255, 0, 255], 2);
                boxes.push({ x, y, width, height });
            }

            cnt.delete();
        }

        cv.imshow(detectedCanvas, src);

        // Zwolnienie pamięci
        src.delete(); gray.delete(); thresh.delete();
        kernel.delete(); contours.delete(); hierarchy.delete();


        let ctx = sourceCanvas.getContext("2d");
        for (let box of boxes) {
            box.imageData = ctx.getImageData(box.x, box.y, box.width, box.height);
        }

        container.appendChild(detectedCanvas);
        document.body.appendChild(container);

        return boxes;
    }

    // funkcja do maskowania niezlewającyc się plamek 2d
    function maskDarkest5Percent(boxes, percent) {
        return boxes.map(box => {
            const { imageData } = box;
            const { data, width, height } = imageData;
            const pixelCount = width * height;

            // Tworzymy tablicę: { index, red } — jeden element na każdy piksel
            let redValues = [];
            for (let i = 0; i < data.length; i += 4) {
                redValues.push({ index: i, red: data[i] }); // data[i] = kanał R
            }

            // Sortujemy rosnąco po czerwonym kanale
            redValues.sort((a, b) => a.red - b.red);

            // Ile to jest 5%?
            const thresholdCount = Math.floor(pixelCount * percent / 100);

            // Iterujemy po 5% najciemniejszych i maskujemy RGB
            for (let i = 0; i < thresholdCount; i++) {
                const idx = redValues[i].index;
                data[idx] = 0;     // R
                data[idx + 1] = 0; // G
                data[idx + 2] = 0; // B
                // data[idx + 3] = alfa — NIE ruszamy
            }

            // Tworzymy nowy ImageData i przypisujemy do box
            box.imageData = new ImageData(data, width, height);
            return box;
        });
    }


    function assignCorners(points) {
      // points: array z 4 punktami {x, y}, z normalizowanymi współrzędnymi (0..1)

      // Sortujemy wg y rosnąco (od góry do dołu)
      const sortedByY = points.slice().sort((a, b) => a.y - b.y);

      // Górne dwa punkty
      const topPoints = sortedByY.slice(0, 2).sort((a, b) => a.x - b.x); // posortowane wg x rosnąco
      // Dolne dwa punkty
      const bottomPoints = sortedByY.slice(2, 4).sort((a, b) => a.x - b.x);

      return {
        topLeftCorner: topPoints[0],
        topRightCorner: topPoints[1],
        bottomLeftCorner: bottomPoints[0],
        bottomRightCorner: bottomPoints[1],
      };
    }    

    // funkcja do właściwego przetwarzania danych:
    function mid_process(id, canvas, sources, processed_sources) {

        if (mode === 'normalise') { // protokół uproszczony dla normalizacji fizycznej oświetlenia
            const extracted_canvas = extractDocumentFromCanvas(id, canvas);
            let boxes = extractBlobsFromCanvas(id, extracted_canvas); 
            boxes = maskDarkest5Percent(boxes, 15); // INPUT* (ile procent odrzucić)
            processed_sources[id] = boxes;
            sources[id] = extracted_canvas;
        }
        else if (mode === 'unnormalise') { // protokół dla zdjęć bez normalizacji fizycznej oświetlenia
            const extracted_canvas = extractDocumentFromCanvas_norm(id, canvas);
            let boxes = extractBlobsFromCanvas(id, extracted_canvas); 
            boxes = maskDarkest5Percent(boxes, 15); // INPUT*
            processed_sources[id] = boxes;
            sources[id] = extracted_canvas;
        }

        console.log("mid_process wywołane z sources:", id, canvas);
    }
//################################# - funkcje do właściwego przetwarzania ^ dla mid_process

//################################# - funkcje do przetwarzania parametrów optymalizacyjnych i ilościowych

    // oblicza ilościówkę
    function analyzeQuantitive(boxes) {
        return boxes.map(box => {
            const { imageData } = box;
            const { data, width, height } = imageData;

            let spotSum = 0;
            let spotSurface = 0;

            for (let i = 0; i < data.length; i += 4) {
                const red = data[i]; // kanał R
                spotSum += red;
                if (red > 0) spotSurface++;
            }

            const spotAverage = spotSurface > 0 ? spotSum / spotSurface : 0;

            box.spotSum = spotSum;
            box.spotSurface = spotSurface;
            box.spotAverage = spotAverage;

            return box;
        });
    }

    // oblicza gdzie jest peak i jaką ma wartość
    function analyzePeak(boxes) { // INPUT*  (podaj jenostkę odległości na piksel)
        return boxes.map(box => {
            const { imageData } = box;
            const { data, width, height } = imageData;

            let maxIntensity = -1;
            let maxX = 0;
            let maxY = 0;

            for (let i = 0; i < data.length; i += 4) {
                const red = data[i];
                const index = i / 4;
                const x = index % width;
                const y = Math.floor(index / width);

                if (red > maxIntensity) {
                    maxIntensity = red;
                    maxX = x;
                    maxY = y;
                }
            }

            box.maxIntensity = maxIntensity;
            box.maxX = maxX;
            box.maxY = maxY;

            return box;
        });
    }

    // oblicza wartości procentowe dla parametró ilościowych
    function analyzeRelativeQuantities(boxes) {
        // Inicjalizacja wartości maksymalnych
        let maxValues = {
            spotSum: 0,
            spotSurface: 0,
            spotAverage: 0,
            maxIntensity: 0
        };

        // Pierwsze przejście - znajdź maksima
        for (const box of boxes) {
            if ('spotSum' in box) maxValues.spotSum = Math.max(maxValues.spotSum, box.spotSum);
            if ('spotSurface' in box) maxValues.spotSurface = Math.max(maxValues.spotSurface, box.spotSurface);
            if ('spotAverage' in box) maxValues.spotAverage = Math.max(maxValues.spotAverage, box.spotAverage);
            if ('maxIntensity' in box) maxValues.maxIntensity = Math.max(maxValues.maxIntensity, box.maxIntensity);
        }

        // Drugie przejście - oblicz wartości procentowe
        for (const box of boxes) {
            if ('spotSum' in box && maxValues.spotSum > 0)
                box.spotSumPercent = (box.spotSum / maxValues.spotSum) * 100;

            if ('spotSurface' in box && maxValues.spotSurface > 0)
                box.spotSurfacePercent = (box.spotSurface / maxValues.spotSurface) * 100;

            if ('spotAverage' in box && maxValues.spotAverage > 0)
                box.spotAveragePercent = (box.spotAverage / maxValues.spotAverage) * 100;

            if ('maxIntensity' in box && maxValues.maxIntensity > 0)
                box.maxIntensityPercent = (box.maxIntensity / maxValues.maxIntensity) * 100;
        }

        return boxes;
    }

    // dodaje linie startu i mety : !!! na razie ustawione na stałe
    function addBoxLines(boxes) {
        return boxes.map(box => {
            box.startLineX = 100; // INPUT*
            box.endLineX = 900; // INPUT*
            box.startLineY = 100; // INPUT*
            box.endLineY = 900; // INPUT*
            return box;
        });
    }

    // dodaje RF, K i RM
    function calculateBoxPositionMetrics(boxes) {
        return boxes.map(box => {
            const {
                startLineX, endLineX, startLineY, endLineY,
                x = 0, y = 0, // pozycja boxa względem obrazu
                maxX = 0, maxY = 0 // maksymalne lokalne pozycje intensywności w boxie
            } = box;

            // Wymiary toru (track width)
            const xTrackWidth = endLineX - startLineX;
            const yTrackWidth = endLineY - startLineY;

            // Pozycja szczytu (peak) na torze
            const xPeakonTrack = x + maxX - startLineX;
            const yPeakonTrack = y + maxY - startLineY;

            // Relative Fraction (RF)
            const xRF = xTrackWidth !== 0 ? xPeakonTrack / xTrackWidth : 0;
            const yRF = yTrackWidth !== 0 ? yPeakonTrack / yTrackWidth : 0;

            // K oraz RF-mapped log wartości
            const xK = xRF > 0 ? (1 - xRF) / xRF : 0;
            const yK = yRF > 0 ? (1 - yRF) / yRF : 0;

            const xRM = xK > 0 ? Math.log10(xK) : null;
            const yRM = yK > 0 ? Math.log10(yK) : null;

            // Dodaj dane do boxa
            Object.assign(box, {
                xTrackWidth,
                yTrackWidth,
                xPeakonTrack,
                yPeakonTrack,
                xRF,
                yRF,
                xK,
                yK,
                xRM,
                yRM
            });

            return box;
        });
    }

    // funkcja pomocnicza - oblicza sumę pikseli - kan. czerw. dla wybranej osi
    function sumRedByAxis(data, width, height, axis = 'x') {
        const result = axis === 'x' ? new Array(width).fill(0) : new Array(height).fill(0);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4; // indeks piksela w data (RGBA)
                const red = data[i];
                if (axis === 'x') {
                    result[x] += red;
                } else {
                    result[y] += red;
                }
            }
        }
        return result;
    }

    // oblicza chartY i chartX
        function calculateBoxCharts(boxes) {
        return boxes.map(box => {
            const { imageData } = box;
            if (!imageData) {
                box.chartX = [];
                box.chartY = [];
                return box;
            }
            const { data, width, height } = imageData;

            box.chartX = sumRedByAxis(data, width, height, 'x');
            box.chartY = sumRedByAxis(data, width, height, 'y');

            return box;
        });
    }

    // funkcja pomocnicza: oblicza długość peaku na danej wysokości
    function peakWidthAtThreshold(chart, thresholdValue) {
        let left = null;
        let right = null;

        for (let i = 0; i < chart.length; i++) {
            if (chart[i] >= thresholdValue) {
                left = i;
                break;
            }
        }

        for (let i = chart.length - 1; i >= 0; i--) {
            if (chart[i] >= thresholdValue) {
                right = i;
                break;
            }
        }

        if (left !== null && right !== null && right >= left) {
            return right - left;
        }
        return 0; // brak piku
    }

    // oblicza długość peaku na danej wysokości
    function calculateWidthsAtThresholds(boxes) {
        return boxes.map(box => {
            const { chartX, chartY, maxIntensity } = box;

            if (!chartX || !chartY || typeof maxIntensity !== 'number') {
                return box;
            }

            const thresholds = {
                'W05': 0.5,
                'W01': 0.1,
                'W005': 0.05,
                'W0': 0.0
            };

            for (const [key, factor] of Object.entries(thresholds)) {
                const thresholdValue = maxIntensity * factor;

                box['x' + key] = peakWidthAtThreshold(chartX, thresholdValue);
                box['y' + key] = peakWidthAtThreshold(chartY, thresholdValue);
            }

            return box;
        });
    }

    // oblicza ile długość peaku na danej wysokości stanowi % długości u podstawy
    function calculateRelativeWidths(boxes) {
        const keys = ['W05', 'W01', 'W005']; // wartości które porównujemy do W0

        return boxes.map(box => {
            const xW0 = box.xW0 || 1; // unikamy dzielenia przez 0
            const yW0 = box.yW0 || 1;

            keys.forEach(key => {
                const xKey = 'x' + key;
                const yKey = 'y' + key;

                const xRelKey = xKey + '%';
                const yRelKey = yKey + '%';

                if (typeof box[xKey] === 'number') {
                    box[xRelKey] = box[xKey] / xW0;
                }

                if (typeof box[yKey] === 'number') {
                    box[yRelKey] = box[yKey] / yW0;
                }
            });

            return box;
        });
    }

    // funkcja pomocnicza: oblicza dystanse A i B
    function findEdgeDistance(chart, threshold, fromStart = true, maxIndex = 0) {
        const len = chart.length;
        let bestIndex = -1;

        if (fromStart) {
            for (let i = 0; i < len; i++) {
                if (chart[i] >= threshold) {
                    bestIndex = i;
                    break;
                }
            }
        } else {
            for (let i = len - 1; i >= 0; i--) {
                if (chart[i] >= threshold) {
                    bestIndex = i;
                    break;
                }
            }
        }

        return bestIndex !== -1 ? Math.abs(bestIndex - maxIndex) : null;
    }

    // oblicza A i B
    function calculateAsymmetryWidths(boxes) {
        return boxes.map(box => {
            const { chartX, chartY, maxIntensity, maxX, maxY } = box;

            if (!chartX || !chartY || maxIntensity == null || maxX == null || maxY == null)
                return box; // pomiń jeśli dane są niekompletne

            const thresholds = {
                '005': 0.05 * maxIntensity,
                '01': 0.10 * maxIntensity
            };

            ['005', '01'].forEach(key => {
                const thr = thresholds[key];

                // Oś X
                const xA = findEdgeDistance(chartX, thr, true, maxX);
                const xB = findEdgeDistance(chartX, thr, false, maxX);
                if (xA != null) box['xA' + key] = xA;
                if (xB != null) box['xB' + key] = xB;

                // Oś Y
                const yA = findEdgeDistance(chartY, thr, true, maxY);
                const yB = findEdgeDistance(chartY, thr, false, maxY);
                if (yA != null) box['yA' + key] = yA;
                if (yB != null) box['yB' + key] = yB;
            });

            return box;
        });
    }

    // oblicza As i T
    function calculateChromatographicAsAndT(boxes) {
        return boxes.map(box => {
            const {
                xA005, xB005, yA005, yB005,
                xA01, xB01, yA01, yB01
            } = box;

            // Oś X
            if (xA01 != null && xB01 != null && xA01 !== 0) {
                box.xAs = xB01 / xA01;
            }

            if (xA005 != null && xB005 != null && xA005 !== 0) {
                box.xT = (xA005 + xB005) / (2 * xA005);
            }

            // Oś Y
            if (yA01 != null && yB01 != null && yA01 !== 0) {
                box.yAs = yB01 / yA01;
            }

            if (yA005 != null && yB005 != null && yA005 !== 0) {
                box.yT = (yA005 + yB005) / (2 * yA005);
            }

            return box;
        });
    }

    // oblicza Hobs
    function calculateHobsParameters(boxes) {
        return boxes.map(box => {
            const {
                xW0, yW0,
                xW05, yW05,
                xPeakonTrack, yPeakonTrack
            } = box;

            if (xW0 != null && xPeakonTrack != null && xPeakonTrack !== 0) {
                box.xHobs0 = Math.pow(xW0, 2) / 16 / xPeakonTrack;
            }

            if (yW0 != null && yPeakonTrack != null && yPeakonTrack !== 0) {
                box.yHobs0 = Math.pow(yW0, 2) / 16 / yPeakonTrack;
            }

            if (xW05 != null && xPeakonTrack != null && xPeakonTrack !== 0) {
                box.xHobs05 = Math.pow(xW05, 2) / 5.54 / xPeakonTrack;
            }

            if (yW05 != null && yPeakonTrack != null && yPeakonTrack !== 0) {
                box.yHobs05 = Math.pow(yW05, 2) / 5.54 / yPeakonTrack;
            }

            return box;
        });
    }

    // oblicza Nobs
    function calculateNobsParameters(boxes) {
        return boxes.map(box => {
            const {
                xPeakonTrack, yPeakonTrack,
                xW0, yW0,
                xW05, yW05
            } = box;

            // USP
            if (xPeakonTrack != null && xW0 != null && xW0 !== 0) {
                box.xNobsUSP = 16 * Math.floor((xPeakonTrack / xW0));
            }

            if (yPeakonTrack != null && yW0 != null && yW0 !== 0) {
                box.yNobsUSP = 16 * Math.floor((yPeakonTrack / yW0));
            }

            // EPS
            if (xPeakonTrack != null && xW05 != null && xW05 !== 0) {
                box.xNobsEPS = 5.54 * Math.pow(Math.floor(xPeakonTrack / xW05), 2);
            }

            if (yPeakonTrack != null && yW05 != null && yW05 !== 0) {
                box.yNobsEPS = 5.54 * Math.pow(Math.floor(yPeakonTrack / yW05), 2);
            }

            return box;
        });
    }

    // wyznacza tracks dla każdej wykrytej plamki
    function assignTracks(boxes) {
        const TOLERANCE = 50; // INPUT*
        const MIN_SURFACE = 1000; // INPUT*

        return boxes.map((box, idx) => {
            const xSum = box.x + box.width;
            const ySum = box.y + box.height;

            // Tracks on Y-axis: compare x + width
            const tracksY = boxes.reduce((acc, otherBox, jdx) => {
                if (jdx === idx) return acc;
                if (otherBox.spotSurface < MIN_SURFACE) return acc;

                const otherXSum = otherBox.x + otherBox.width;
                if (Math.abs(otherXSum - xSum) <= TOLERANCE) {
                    acc.push(jdx);
                }
                return acc;
            }, []);

            // Tracks on X-axis: compare y + height
            const tracksX = boxes.reduce((acc, otherBox, jdx) => {
                if (jdx === idx) return acc;
                if (otherBox.spotSurface < MIN_SURFACE) return acc;

                const otherYSum = otherBox.y + otherBox.height;
                if (Math.abs(otherYSum - ySum) <= TOLERANCE) {
                    acc.push(jdx);
                }
                return acc;
            }, []);

            box.tracksY = tracksY;
            box.tracksX = tracksX;

            return box;
        });
    }

    // funkcja wyznacza bezpośredniego poprzednika na torze x / y
    function addPreviousTrackParameters(boxes) {
        return boxes.map((currentBox, currentIndex) => {
            const { x: currentX, y: currentY, tracksX = [], tracksY = [] } = currentBox;

            let previousXIndex = null;
            let maxX = -Infinity;
            for (const idx of tracksX) {
                if (idx === currentIndex) continue;
                const otherBox = boxes[idx];
                if (otherBox?.x != null && otherBox.x < currentX && otherBox.x > maxX) {
                    maxX = otherBox.x;
                    previousXIndex = idx;
                }
            }

            let previousYIndex = null;
            let maxY = -Infinity;
            for (const idx of tracksY) {
                if (idx === currentIndex) continue;
                const otherBox = boxes[idx];
                if (otherBox?.y != null && otherBox.y < currentY && otherBox.y > maxY) {
                    maxY = otherBox.y;
                    previousYIndex = idx;
                }
            }

            currentBox.previousX = previousXIndex;
            currentBox.previousY = previousYIndex;

            return currentBox;
        });
    }

    // oblicza parametry alpha
    function addAlphaParameters(boxes) {
        return boxes.map((box, index) => {
            const { xK, yK, previousX, previousY } = box;

            // Obliczanie αx
            if (xK != null && previousX != null) {
                const prevBox = boxes[previousX];
                if (prevBox?.xK != null) {
                    const k1 = Math.min(xK, prevBox.xK);
                    const k2 = Math.max(xK, prevBox.xK);
                    if (k1 !== 0) {
                        box.alphaX = k2 / k1;
                    }
                }
            }

            // Obliczanie αy
            if (yK != null && previousY != null) {
                const prevBox = boxes[previousY];
                if (prevBox?.yK != null) {
                    const k1 = Math.min(yK, prevBox.yK);
                    const k2 = Math.max(yK, prevBox.yK);
                    if (k1 !== 0) {
                        box.alphaY = k2 / k1;
                    }
                }
            }

            return box;
        });
    }

    // obliczza parametry RS
    function addRSParameters(boxes) {
        return boxes.map((box, index) => {
            const { xPeakonTrack: z2x, yPeakonTrack: z2y, xW0: w2x, yW0: w2y, previousX, previousY } = box;

            // RSx
            if (previousX != null) {
                const prevBox = boxes[previousX];
                const z1x = prevBox?.xPeakonTrack;
                const w1x = prevBox?.xW0;

                if (z1x != null && w1x != null && z2x != null && w2x != null && (w1x + w2x) !== 0) {
                    box.RSx = (z2x - z1x) / 0.5 / (w1x + w2x);
                }
            }

            // RSy
            if (previousY != null) {
                const prevBox = boxes[previousY];
                const z1y = prevBox?.yPeakonTrack;
                const w1y = prevBox?.yW0;

                if (z1y != null && w1y != null && z2y != null && w2y != null && (w1y + w2y) !== 0) {
                    box.RSy = (z2y - z1y) / 0.5 / (w1y + w2y);
                }
            }

            return box;
        });
    }

    // oblicza selectivity
    function addSelectivityParameters(boxes) {
        return boxes.map((box) => {
            const { xK: k2x, yK: k2y, previousX, previousY } = box;

            // selectivityX
            if (previousX != null) {
                const prevBox = boxes[previousX];
                const k1x = prevBox?.xK;

                if (k1x != null && k1x !== 0 && k2x != null) {
                    box.selectivityX = 0.25 * Math.floor(k2x / k1x - 1);
                }
            }

            // selectivityY
            if (previousY != null) {
                const prevBox = boxes[previousY];
                const k1y = prevBox?.yK;

                if (k1y != null && k1y !== 0 && k2y != null) {
                    box.selectivityY = 0.25 * Math.floor(k2y / k1y - 1);
                }
            }

            return box;
        });
    }

    // oblicza efficiency
    function addEfficiencyParameters(boxes) {
        return boxes.map(box => {
            const { xRF, yRF, previousX, previousY, xNobsUSP, xNobsEPS, yNobsUSP, yNobsEPS } = box;

            // RFavgX
            let RFavgX = null;
            if (xRF != null && previousX != null) {
                const prevBox = boxes[previousX];
                if (prevBox?.xRF != null) {
                    RFavgX = (xRF + prevBox.xRF) / 2;
                    box.xRFavg = RFavgX;
                }
            }

            // RFavgY
            let RFavgY = null;
            if (yRF != null && previousY != null) {
                const prevBox = boxes[previousY];
                if (prevBox?.yRF != null) {
                    RFavgY = (yRF + prevBox.yRF) / 2;
                    box.yRFavg = RFavgY;
                }
            }

            // Oblicz efficiency, jeśli dane dostępne
            if (RFavgX != null) {
                if (xNobsUSP != null) {
                    box.xEfficiencyUSP = Math.sqrt(RFavgX  * xNobsUSP);
                }
                if (xNobsEPS != null) {
                    box.xEfficiencyEPS = Math.sqrt(RFavgX  * xNobsEPS);
                }
            }

            if (RFavgY != null) {
                if (yNobsUSP != null) {
                    box.yEfficiencyUSP = Math.sqrt(RFavgY  * yNobsUSP);
                }
                if (yNobsEPS != null) {
                    box.yEfficiencyEPS = Math.sqrt(RFavgY * yNobsEPS);
                }
            }

            return box;
        });
    }

    // oblicza retention
    function addRetentionParameters(boxes) {
        return boxes.map(box => {
            const { xRFavg, yRFavg } = box;

            box.xRetention = xRFavg != null ? 1 - xRFavg : null;
            box.yRetention = yRFavg != null ? 1 - yRFavg : null;

            return box;
        });
    }

    // dodaje RS z tego złożonego wzoru
    function addRSParametersComplex(boxes) {
        return boxes.map(box => {
            const {
                xRetention, yRetention,
                xEfficiencyUSP, xEfficiencyEPS,
                yEfficiencyUSP, yEfficiencyEPS,
                selectivityX, selectivityY
            } = box;

            // Obliczenia tylko jeśli wszystkie potrzebne wartości są dostępne
            box.RSxUSP = (
                selectivityX != null && xEfficiencyUSP != null && xRetention != null
            ) ? selectivityX * xEfficiencyUSP * xRetention : null;

            box.RSxEPS = (
                selectivityX != null && xEfficiencyEPS != null && xRetention != null
            ) ? selectivityX * xEfficiencyEPS * xRetention : null;

            box.RSyUSP = (
                selectivityY != null && yEfficiencyUSP != null && yRetention != null
            ) ? selectivityY * yEfficiencyUSP * yRetention : null;

            box.RSyEPS = (
                selectivityY != null && yEfficiencyEPS != null && yRetention != null
            ) ? selectivityY * yEfficiencyEPS * yRetention : null;

            return box;
        });
    }


//################################# - funkcje do przetwarzania parametrów optymalizacyjnych

//################################# - funkcje do postprocesingu

    // funkcja do końcowego przetwarzania danych
    function final_process(sources, processed_sources) {
        console.log("final_process wywołane z sources:", processed_sources);

        // Iteracja w kolejności dodania (klucze obiektów w JS zachowują kolejność)
        Object.keys(sources).forEach(id => {
            const sourceCanvas = sources[id];
            const processedData = processed_sources[id];

            // Przetwórz dane przez analizator
            const spots= postprocess_analysis(processedData);

            // Stwórz kontener

            // Główna karta
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'card mb-4';

            // Nagłówek z przyciskami toggle
            const cardHeader = document.createElement('div');
            cardHeader.className = 'card-header d-flex gap-2 flex-wrap';

            const toggleMain = document.createElement('button');
            toggleMain.className = 'btn btn-sm btn-outline-primary';
            toggleMain.type = 'button';
            toggleMain.setAttribute('data-bs-toggle', 'collapse');
            toggleMain.setAttribute('data-bs-target', `#collapse-main-${id}`);
            toggleMain.textContent = 'Pokaż/Wyłącz obraz';

            const toggleDesc = document.createElement('button');
            toggleDesc.className = 'btn btn-sm btn-outline-secondary';
            toggleDesc.type = 'button';
            toggleDesc.setAttribute('data-bs-toggle', 'collapse');
            toggleDesc.setAttribute('data-bs-target', `#collapse-desc-${id}`);
            toggleDesc.textContent = 'Pokaż/Wyłącz opis';

            cardHeader.appendChild(toggleMain);
            cardHeader.appendChild(toggleDesc);
            cardWrapper.appendChild(cardHeader);

            // Kontener na sekcję: ( obraz + przyciski )
            const container = document.createElement('div');
            container.className = 'collapse show';
            container.id = `collapse-main-${id}`;
            container.classList.add('card-body');

            // Kontener na obraz + przyciski
            const img_container = document.createElement('div');
            img_container.className = 'canvas-result mb-4';
            img_container.id = `image_show-${id}`;
            img_container.style.position = 'relative';  // Pozycjonowanie względem tego kontenera
            container.appendChild(img_container);

            // Kontener na opis/tabelę
            const description_container = document.createElement('div');
            description_container.className = 'collapse show row g-3';
            description_container.id = `collapse-desc-${id}`;
            description_container.classList.add('card-body');

            // Dodaj oba kontenery do głównej karty
            cardWrapper.appendChild(container);
            cardWrapper.appendChild(description_container);

            // Stwórz kopię canvasu
            // 1. Konwersja do PNG (base64)
            const pngDataURL = sourceCanvas.toDataURL('image/png');

            // 2. Tworzymy <img> z zakodowanym PNG
            const imageElement = document.createElement('img');
            imageElement.src = pngDataURL;
            imageElement.alt = `Wynik ${id}`;
            imageElement.style.display = 'block';
            imageElement.style.width = '100%';  // bardzo ważne, by obraz się skalował względem kontenera
            imageElement.style.border = '1px solid #ccc';

            img_container.appendChild(imageElement);

            // Poczekaj, aż obraz się załaduje, aby znać jego wymiary
            imageElement.onload = () => {
                const imgWidth = imageElement.naturalWidth;
                const imgHeight = imageElement.naturalHeight;

                spots.forEach((spot, index) => {
                    const { x, y, width, height } = spot;

                    const btn = document.createElement('button');
                    btn.textContent = `${id}#${index}`;
                    btn.style.position = 'absolute';

                    // Pozycjonuj względem oryginalnych wymiarów obrazu
                    btn.style.left = `${(x / imgWidth) * 100}%`;
                    btn.style.top = `${(y / imgHeight) * 100}%`;
                    btn.style.width = `${(width / imgWidth) * 100}%`;
                    btn.style.height = `${(height / imgHeight) * 100}%`;

                    btn.style.background = 'rgba(255,0,0,0.3)';
                    btn.style.border = '1px solid red';
                    btn.style.color = 'yellow';
                    btn.style.fontSize = '10px';
                    btn.style.cursor = 'pointer';
                    btn.title = `Plamka ${index}`;

                    btn.addEventListener('click', () => {
                        const tableRow = document.getElementById(`spot-${id}-${index}`);
                        if (tableRow) {
                            tableRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            tableRow.style.backgroundColor = 'yellow';
                            setTimeout(() => {
                                tableRow.style.backgroundColor = '';
                            }, 1000);
                        }
                    });

                    img_container.appendChild(btn);

            // Tworzenie tabeli parametrów

                        // Wrapper kolumny dla tabeli
                        const colWrapper = document.createElement('div');
                        colWrapper.className = 'col-12 col-md-6 col-lg-4'; // pełna szerokość w mobile, 2 kolumny na md, 3 na lg+

                        // Nagłówek nad tabelą
                        const caption = document.createElement('h6');
                        caption.textContent = `Parametry Plamki #${index}`;
                        caption.className = 'fw-bold mb-2';

                        // Tabela
                        const table = document.createElement('table');
                        table.className = 'table table-sm table-bordered table-striped w-100';

                        // Iteracja po danych
                        Object.entries(spot).forEach(([key, value]) => {
                            if (key === 'imageData') return;
                            if (key === 'chartX') return;
                            if (key === 'chartY') return;

                            const row = document.createElement('tr');
                            row.id = `spot-${id}-${index}`;

                            const cellKey = document.createElement('td');
                            cellKey.textContent = key;
                            cellKey.className = 'fw-light';

                            const cellValue = document.createElement('td');
                            cellValue.textContent = value;

                            row.appendChild(cellKey);
                            row.appendChild(cellValue);
                            table.appendChild(row);
                        });

                        // Składanie całości
                        colWrapper.appendChild(caption);
                        colWrapper.appendChild(table);
                        description_container.appendChild(colWrapper);        
                });
            };

            // Umieść cały wynik na stronie
            document.body.appendChild(cardWrapper);
        });
    }

//################################# - funkcje do postprocesingu


//################################# - funkcje dla przyciskó akcji
// zmienia parametry wymagające zmiany
function applyConfigChanges(){
    mode = getString('normalisation_mode', 'unnormalise'); // 'normalise' , 'unnormalise' // INPUT* 
}
// czyści dane przetworzone
function clearSources() {
    sources = {};
    processed_sources = {};
    alert('Dane źródłowe i wyniki zostały wyczyszczone.');
}


function convertTableUnits() { // do wyrzucenia
    // przyjmujemy, że 1 px przypada na długość boku płtyki
    // przyjmujemy, że płytka ma 10 cm

    const keyWords_mm2 = [ 'spotSurface'];
    const keyWords_mm = ['x', 'y', 'width', 'height'];
    const allTables = document.querySelectorAll("table");

    allTables.forEach(table => {
        const rows = table.querySelectorAll("tr");
        rows.forEach(row => {
            const cells = row.querySelectorAll("td, th");
            if (cells.length < 2) return;

            const label = cells[0].innerText.trim();
            const valueCell = cells[1];

            const text = valueCell.innerText.trim();

            // Dopasuj liczby i jednostki
            const match = text.match(/^([0-9.,]+)\s*(mm²|mm)?$/i);
            if (!match) return;

            let number = parseFloat(match[1].replace(",", "."));
            const unit = match[2]?.toLowerCase();

            if (keyWords_mm2.includes(label)) {
                if (!unit) {
                    // Bez jednostki, liczba w px² → przelicz na mm²
                    number = number * 0.01;
                    valueCell.innerText = number.toFixed(2) + " mm²";
                } else if (unit === 'mm²') {
                    // Jest mm² → przelicz na px²
                    number = number / 0.01;
                    valueCell.innerText = Math.round(number); // bez jednostki
                }
            } else if (keyWords_mm.includes(label)) {
                if (!unit) {
                    // Bez jednostki, liczba w px → przelicz na mm
                    number = number * 0.1;
                    valueCell.innerText = number.toFixed(2) + " mm";
                } else if (unit === 'mm') {
                    // Jest mm → przelicz na px
                    number = number / 0.1;
                    valueCell.innerText = Math.round(number); // bez jednostki
                }
            }
        });
    });
}
//################################# - funkcje dla przyciskó akcji


//################################# - funkcje do definiowania przepływu pracy

    // funkcja obsługująca kolejność przepływu przetwarzania
    function handleCanvasInput(canvas, id, sources, processed_sources, limit) {
        const currentSize = Object.keys(sources).length;

        // Zapisz canvas do sources
        sources[id] = canvas;

        if (limit <= 0) {
            console.warn("Niepoprawna wartość limitu:", limit);
            return;
        }

        if (limit === 1) {
            pre_process(id, canvas, sources, processed_sources);
            final_process(sources, processed_sources);
        } else if (limit === 2) {
            if (currentSize === 0) {
                pre_process(id, canvas, sources, processed_sources);
            } else if (currentSize === 1) {
                mid_process(id, canvas, sources, processed_sources);
                final_process(sources, processed_sources);
            }
        } else { // limit >= 3
            if (currentSize === 0) {
                pre_process(id, canvas, sources, processed_sources);
            } else if (currentSize < limit - 1) {
                mid_process(id, canvas, sources, processed_sources);
            } else if (currentSize === limit - 1) {
                mid_process(id, canvas, sources, processed_sources);
                final_process(sources, processed_sources);
            }
        }
    }


    // wywoływany po każdym załadowaniu ew. uśrednieniu obrazu
    window.addEventListener('newScan', (e) => {
        handleCanvasInput(e.detail.canvas, e.detail.id, sources, processed_sources, limit);
    });

//################################# - funkcje do definiowania przepływu pracy    

//*********************************
// Przykład aplikacji TLC w frameworku low-code (JavaScript)
// Autor: [Twoje Imię]
// Cel: Analiza TLC na podstawie 3 obrazów – UV 254 nm, UV 365 nm i światło zielone
// Ten kod tworzy aplikację za pomocą gotowych funkcji wysokiego poziomu.
//*********************************

// 🟩 Komentarze opisują każdą sekcję zrozumiale dla człowieka i AI.

// 1️⃣ Dodajemy komentarze/etykiety opisujące kolejne sekcje aplikacji.
// Funkcja addCommentCell(id, tekst, element_docelowy) dodaje komentarz HTML do interfejsu.

// 2️⃣ Dodajemy panele do ładowania obrazów dla 3 różnych źródeł.
// Funkcja images(id, trigger) tworzy panel ładowania obrazów.
// - id: unikalny identyfikator
// - trigger: true = uruchom przetwarzanie automatycznie po załadowaniu
addCommentCell('comment-1', 'Załaduj obraz dla UV 254 nm', document.body);
images("uv-254", true);

// i powtarzamy schemat

/*
addCommentCell('comment-2', 'Załaduj obraz dla UV 365 nm', document.body);
images("uv-365", true);

addCommentCell('comment-3', 'Załaduj obraz w świetle zielonym (widzialnym)', document.body);
images("green-visible", true);
*/


// 3️⃣ Inicjalizujemy obiekty na dane.
// - sources: dane wejściowe z obrazów
// - processed_sources: dane przetworzone
// - limit: liczba oczekiwanych źródeł (dla synchronizacji)
// - corners: współrzędne rogów płytki TLC
let sources = {};
let processed_sources = {};
const limit = 1;
let corners;
let mode = getString('normalisation_mode', 'unnormalise'); // 'normalise' , 'unnormalise' // INPUT* 
let data = loadFromStorage('procParams'); // obiekt przetrzymuje wszystkie modyfikowalne ustawienia

  // Definiowanie listy kluczy i callbacków do nasłuchiwania zmian w localStorage
  window.__watchList = [
    ['procParams', (event) => { // [storage key, function for this storage key] - note not param key
        data = JSON.parse(event.newValue); // can also use explicit name
        console.log(data);
      // Możesz np. zaktualizować UI
    }]
  ];

  // tworzy panel przycisków - linków do nowych zakładek dla programu - są otwierane w nowej zakłądce
  createButtonGrid([
    ['⚙️', 'https://git.1ioe.top/TLC/v5/params.html'],
  ]);

// 4️⃣ Tworzymy panel parametrów analizy.
// Funkcja parameterTable(id, tablica_parametrów) generuje pola wejściowe do ustawiania wartości progów, symetrii itd.
// Format: [etykieta, id_parametru, domyślna_wartość]
parameterTable('parametry-progu', [
    ['⚠️ tryb normalizacji oświetlenia (normalise / unnormalise):', 'normalisation_mode', 'unnormalise'], 
    // ✅ - tego użyj dla parametrów nie wymagających zatwiedzenia
]);

// 5️⃣ Tworzymy panel z przyciskami do akcji.
// Funkcja parameterButtons(id, lista_przycisków) generuje przyciski interaktywne.
// Format: [ikona/tekst, tekst pomocy, funkcja_do_uruchomienia]
// funkcje te pozwalają na dodanie własnej niskopoziomowej logiki
parameterButtons('panel-akcji', [
    ['🔁📐', 'zamień jednostki z pikseli na mm / mm2 i na odwrót', convertTableUnits],
    ['🧪', 'Zastosuj zmianę parametrów.', applyConfigChanges],
    ['🧹', 'Wyczyść dane źródłowe i wyniki.', clearSources],
    ['💾', 'Zapisz dane na dysku.', () => alert('Zapisano!')]
]);

// 6️⃣ Definiujemy funkcję przetwarzania końcowego.
// Funkcja postprocess_analysis(data) wykonuje dodatkową analizę danych (np. statystyki, oznaczanie kolorów).
// Może być wieloetapowa, np. filtrowanie, analiza kanału kolorów itp.
function postprocess_analysis(processedData) {
    let data = processedData;
    // poniżej oznaczam w jakiej kolejności muszą być wykonane funkcje analizy
    data = analyzeQuantitive(data); // 1
    data = analyzePeak(data); // 1
    data = analyzeRelativeQuantities(data); // 2
    data = addBoxLines(data); // 1
    data = calculateBoxPositionMetrics(data); // 3
    data = calculateBoxCharts(data); // 1
    data = calculateWidthsAtThresholds(data); // 3
    data = calculateRelativeWidths(data); // 4
    data = calculateAsymmetryWidths(data); // 5
    data = calculateChromatographicAsAndT(data); // 6
    data = calculateHobsParameters(data); // 7
    data = calculateNobsParameters(data); // 7
    data = assignTracks(data); // 8
    data = addPreviousTrackParameters(data); // 9
    data = addAlphaParameters(data); // 10
    data = addRSParameters(data); // 10
    data = addSelectivityParameters(data); // 11
    data = addEfficiencyParameters(data); // 11
    data = addRetentionParameters(data); // 12
    data = addRSParametersComplex(data); // 13
    
    // Można dodać więcej funkcji analitycznych, np. na kanał zielony lub porównanie UV vs VIS
    // data = analyzeGreenChannel(data);
    // data = compareSpotsAcrossSources(data);

    return data;
}


//*********************************
// Uwaga dla AI i przyszłych programistów:
// - Framework ten pozwala tworzyć aplikacje przez opis struktury i funkcji.
// - Użytkownik nie pisze niskopoziomowego kodu HTML ani event listenerów – wszystko działa przez funkcje deklaratywne.
// - Dzięki temu można szybko stworzyć aplikację do analizy obrazów TLC z wieloma źródłami światła.
//*********************************


  </script>
</html>