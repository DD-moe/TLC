<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Damian Bezara, Karol Wróblewski">
    <meta name="creator" content="Damian Bezara">
    <meta name="keywords" content="TLC, chromatography, analysis, Damian Bezara, Karol Wróblewski, chemical analysis, quantitative analysis, open-source">
    <title>TLC Plate Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Konfiguracja czcionki Inter */
        :root {
            font-family: 'Inter', sans-serif;
        }
        /* Styl dla obszarów canvas */
        canvas {
            border: 1px solid #ccc;
            background-color: #f7f7f7;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body class="bg-gray-50 p-4 sm:p-8">

    <div class="max-w-4xl mx-auto space-y-8">
        <h1 class="text-3xl font-bold text-gray-800 text-center">
            How to reconstruct TLC plate data.
        </h1>
        <p class="text-center text-sm text-gray-600">
            Load an image to be downscaled by 10x. Then, 3D linear regressions ($C(x, y) = a_0 + a_1 x + a_2 y$) will be fitted for each channel (R, G, B). Finally, the image will be reconstructed based on these models.
        </p>

        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-100 space-y-4">
            
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="outputWidth" class="block text-sm font-medium text-gray-700">Output Width (px)</label>
                    <input type="number" id="outputWidth" value="400" min="10" class="mt-1 block w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="outputHeight" class="block text-sm font-medium text-gray-700">Output Height (px)</label>
                    <input type="number" id="outputHeight" value="600" min="10" class="mt-1 block w-full p-2 border border-gray-300 rounded-lg text-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <p class="col-span-2 text-xs text-gray-500">Ustawienie tych wartości przeskaluje zrekonstruowany obraz do podanego rozmiaru, zanim zostaną nałożone plamy TLC.</p>
            </div>
            
            <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                <input type="file" id="imageInput" accept="image/*" class="block w-full text-sm text-gray-700
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-lg file:border-0
                    file:text-sm file:font-semibold
                    file:bg-indigo-50 file:text-indigo-700
                    hover:file:bg-indigo-100 cursor-pointer
                "/>
                <button id="processButton" disabled class="w-full sm:w-auto px-6 py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition duration-150 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    Load & Process
                </button>
            </div>
            
            <div>
                <label for="spotData" class="block text-sm font-medium text-gray-700 mb-2">TLC Spot Data (JSON Array)</label>
                <textarea id="spotData" rows="5" class="w-full p-2 border border-gray-300 rounded-lg font-mono text-xs focus:ring-indigo-500 focus:border-indigo-500" placeholder='[
    { "x": 0.5, "y": 0.7, "width": 0.1, "height": 0.05, "color": "#FF0000", "intensity": 0.8 },
    { "x": 0.3, "y": 0.5, "width": 0.08, "height": 0.08, "color": "#00FF00", "intensity": 0.6 }
]'></textarea>
                <p class="text-xs text-gray-500 mt-1">Coordinates and sizes are normalized (0-1). Intensity is a blending factor (0-1).</p>
            </div>
            
            <button id="drawSpotsButton" disabled class="w-full px-6 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-150 disabled:bg-gray-400 disabled:cursor-not-allowed">
                Apply TLC Spots to Reconstruction
            </button>
        </div>

        <div id="results" class="space-y-6">
            <div class="text-center">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Original Image downscaled 10 times</h2>
                <canvas id="originalCanvas" class="rounded-lg shadow-inner"></canvas>
                <p id="originalInfo" class="text-sm text-gray-500 mt-1"></p>
            </div>
            
            <div class="text-center">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Reconstructed Image with Spots</h2>
                <canvas id="regressionCanvas" class="rounded-lg shadow-inner"></canvas>
                <p id="regressionInfo" class="text-sm text-gray-500 mt-1"></p>
            </div>
            
            <div id="statusMessage" class="min-h-12 bg-yellow-100 text-yellow-800 p-4 rounded-lg text-center font-medium hidden"></div>

            <div id="coefficients" class="bg-white p-6 rounded-xl shadow-lg border border-gray-100 hidden">
                <h3 class="text-lg font-bold text-gray-700 mb-3">Reggression Coefficients (a₀, a₁, a₂)</h3>
                <pre id="coeffPre" class="overflow-x-auto bg-gray-50 p-3 rounded-lg text-sm text-gray-800"></pre>
            </div>
        </div>
    </div>

    <script>
        // --- Referencje do DOM ---
        const imageInput = document.getElementById('imageInput');
        const processButton = document.getElementById('processButton');
        const drawSpotsButton = document.getElementById('drawSpotsButton');
        const spotDataTextarea = document.getElementById('spotData');
        const originalCanvas = document.getElementById('originalCanvas');
        const regressionCanvas = document.getElementById('regressionCanvas');
        const outputWidthInput = document.getElementById('outputWidth'); // Nowy input
        const outputHeightInput = document.getElementById('outputHeight'); // Nowy input
        const originalCtx = originalCanvas.getContext('2d');
        const regressionCtx = regressionCanvas.getContext('2d');
        const statusMessage = document.getElementById('statusMessage');
        const coeffPre = document.getElementById('coeffPre');
        const coefficientsDiv = document.getElementById('coefficients');
        const originalInfo = document.getElementById('originalInfo');
        const regressionInfo = document.getElementById('regressionInfo');

        // Utworzenie off-screen canvas dla rysowania plam
        const spotCanvas = document.createElement('canvas');
        const spotCtx = spotCanvas.getContext('2d');

        const DOWNSCALE_FACTOR = 10;
        let downscaledWidth = 0;
        let downscaledHeight = 0;
        let originalImageData = null; 
        
        // Klucze Local Storage
        const LS_WIDTH_KEY = 'tlcOutputWidth';
        const LS_HEIGHT_KEY = 'tlcOutputHeight';
        const LS_SPOTDATA_KEY = 'tlcSpotData';

        // --- FUNKCJE DLA LOCAL STORAGE ---

        /**
         * Zapisuje wartość elementu do Local Storage.
         * @param {string} key Klucz Local Storage.
         * @param {HTMLElement} element Element DOM.
         */
        function saveToLocalStorage(key, element) {
            try {
                localStorage.setItem(key, element.value);
            } catch (e) {
                console.error("Błąd zapisu Local Storage:", e);
            }
        }

        /**
         * Wczytuje wartość elementu z Local Storage.
         * @param {string} key Klucz Local Storage.
         * @param {HTMLElement} element Element DOM.
         * @param {string} defaultValue Wartość domyślna, jeśli brak w LS.
         */
        function loadFromLocalStorage(key, element, defaultValue = '') {
            try {
                const storedValue = localStorage.getItem(key);
                if (storedValue !== null) {
                    element.value = storedValue;
                } else if (defaultValue !== '') {
                    element.value = defaultValue;
                }
            } catch (e) {
                console.error("Błąd odczytu Local Storage:", e);
            }
        }

        /**
         * Ustawia Listenery do automatycznego zapisywania i wczytuje dane początkowe.
         */
        function initializeLocalStorage() {
            // Wczytywanie danych
            loadFromLocalStorage(LS_WIDTH_KEY, outputWidthInput, '400');
            loadFromLocalStorage(LS_HEIGHT_KEY, outputHeightInput, '600');
            loadFromLocalStorage(LS_SPOTDATA_KEY, spotDataTextarea, spotDataTextarea.placeholder);

            // Ustawianie listenerów dla automatycznego zapisu
            outputWidthInput.addEventListener('change', () => saveToLocalStorage(LS_WIDTH_KEY, outputWidthInput));
            outputHeightInput.addEventListener('change', () => saveToLocalStorage(LS_HEIGHT_KEY, outputHeightInput));
            spotDataTextarea.addEventListener('change', () => saveToLocalStorage(LS_SPOTDATA_KEY, spotDataTextarea));
            spotDataTextarea.addEventListener('input', () => saveToLocalStorage(LS_SPOTDATA_KEY, spotDataTextarea)); // Dodatkowe na input
        }

        // --- FUNKCJE POMOCNICZE DO ALGEBRY LINIOWEJ (Macierz 3x3) ---

        function transpose(matrix) {
            return matrix[0].map((col, c) => matrix.map(row => row[c]));
        }

        function multiply(A, B) {
            const rowsA = A.length;
            const colsA = A[0].length;
            const rowsB = B.length;
            const colsB = B[0].length;
            
            if (colsA !== rowsB) {
                console.error("Wymiary macierzy są niezgodne do mnożenia.");
                return null;
            }

            let result = new Array(rowsA).fill(0).map(() => new Array(colsB).fill(0));

            for (let i = 0; i < rowsA; i++) {
                for (let j = 0; j < colsB; j++) {
                    let sum = 0;
                    for (let k = 0; k < colsA; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    result[i][j] = sum;
                }
            }
            return result;
        }

        function inverse3x3(M) {
            const [
                [a, b, c],
                [d, e, f],
                [g, h, i]
            ] = M;

            const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);

            if (Math.abs(det) < 1e-9) {
                console.error("Wyznacznik jest bliski zeru. Macierz jest osobliwa.");
                return null;
            }

            const invDet = 1 / det;

            const adj = [
                [e * i - f * h, c * h - b * i, b * f - c * e],
                [f * g - d * i, a * i - c * g, c * d - a * f],
                [d * h - e * g, b * g - a * h, a * e - b * d]
            ];

            const result = adj.map(row => row.map(val => val * invDet));
            return result;
        }
        
        function solveLeastSquares(X, C) {
            const XT = transpose(X);
            const A = multiply(XT, X);
            const B = multiply(XT, C);

            if (!A || !B) return null;

            const A_inv = inverse3x3(A);

            if (!A_inv) {
                statusMessage.textContent = "Błąd: Macierz X^T * X jest osobliwa, nie można wykonać regresji dla tego kanału.";
                statusMessage.classList.remove('hidden');
                return null;
            }

            const coeffsMatrix = multiply(A_inv, B);

            return coeffsMatrix.map(row => row[0]); 
        }

        // --- GŁÓWNA LOGIKA APLIKACJI ---
        
        let regressionCoefficients = { r: null, g: null, b: null };

        // Umożliwia kliknięcie przycisku po wybraniu pliku
        imageInput.addEventListener('change', () => {
            processButton.disabled = !imageInput.files.length;
            drawSpotsButton.disabled = true;
            statusMessage.classList.add('hidden');
        });

        processButton.addEventListener('click', processImage);
        drawSpotsButton.addEventListener('click', () => {
             if (originalImageData) {
                // Wykonaj rysowanie plam na zrekonstruowanym obrazie
                const newW = parseInt(outputWidthInput.value) || 1;
                const newH = parseInt(outputHeightInput.value) || 1;
                drawSpotsAndBlend(newW, newH, originalImageData);
            }
        });

        /**
         * Główne kroki: ładowanie, downscaling i obliczanie regresji.
         */
        async function processImage() {
            const file = imageInput.files[0];
            if (!file) return;

            statusMessage.textContent = "Trwa ładowanie i przetwarzanie obrazu...";
            statusMessage.classList.remove('hidden');
            statusMessage.classList.remove('bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800');
            statusMessage.classList.add('bg-yellow-100', 'text-yellow-800');
            processButton.disabled = true;
            drawSpotsButton.disabled = true;
            
            // Pobierz docelowe wymiary wyjściowe
            const targetWidth = parseInt(outputWidthInput.value);
            const targetHeight = parseInt(outputHeightInput.value);
            
            // Walidacja wymiarów
            if (targetWidth <= 0 || targetHeight <= 0 || isNaN(targetWidth) || isNaN(targetHeight)) {
                statusMessage.textContent = "Błąd: Wymiary wyjściowe muszą być dodatnimi liczbami całkowitymi.";
                statusMessage.classList.remove('bg-yellow-100', 'text-yellow-800');
                statusMessage.classList.add('bg-red-100', 'text-red-800');
                processButton.disabled = false;
                return;
            }

            const img = new Image();
            img.onload = async () => {
                try {
                    // Krok 1: Downscaling (10-krotne)
                    const originalWidth = img.width;
                    const originalHeight = img.height;
                    downscaledWidth = Math.floor(originalWidth / DOWNSCALE_FACTOR);
                    downscaledHeight = Math.floor(originalHeight / DOWNSCALE_FACTOR);

                    // Ustawienie rozmiaru canvasu do downscalingu
                    originalCanvas.width = downscaledWidth;
                    originalCanvas.height = downscaledHeight;

                    // Rysowanie i downscaling
                    originalCtx.clearRect(0, 0, downscaledWidth, downscaledHeight);
                    originalCtx.drawImage(img, 0, 0, originalWidth, originalHeight, 0, 0, downscaledWidth, downscaledHeight);

                    // Krok 2: Pobranie ImageData (dla macierzy regresji)
                    const imageData = originalCtx.getImageData(0, 0, downscaledWidth, downscaledHeight);
                    const data = imageData.data;
                    const N = downscaledWidth * downscaledHeight;

                    statusMessage.textContent = `Pobrano dane. Rozpoczynanie obliczeń regresji dla ${N} pikseli...`;
                    await new Promise(r => setTimeout(r, 10));

                    // Krok 3: Przygotowanie danych i obliczenie regresji dla R, G, B

                    const colorVectors = { r: [], g: [], b: [] };
                    const X = []; 

                    for (let y = 0; y < downscaledHeight; y++) {
                        for (let x = 0; x < downscaledWidth; x++) {
                            const i = (y * downscaledWidth + x) * 4;
                            X.push([1, x, y]);
                            colorVectors.r.push([data[i]]);
                            colorVectors.g.push([data[i + 1]]);
                            colorVectors.b.push([data[i + 2]]);
                        }
                    }

                    regressionCoefficients.r = solveLeastSquares(X, colorVectors.r);
                    regressionCoefficients.g = solveLeastSquares(X, colorVectors.g);
                    regressionCoefficients.b = solveLeastSquares(X, colorVectors.b);

                    if (!regressionCoefficients.r || !regressionCoefficients.g || !regressionCoefficients.b) {
                        statusMessage.textContent = "Błąd: Nie udało się rozwiązać regresji dla wszystkich kanałów.";
                        processButton.disabled = false;
                        return;
                    }

                    // Krok 4: Rekonstrukcja obrazu na podstawie regresji do ŻĄDANEGO rozmiaru
                    // Używamy targetWidth/Height do zdefiniowania rozmiaru wyjściowego
                    
                    // Zmiana rozmiaru canvasów wyjściowych na żądany przez użytkownika rozmiar
                    regressionCanvas.width = targetWidth;
                    regressionCanvas.height = targetHeight;
                    spotCanvas.width = targetWidth;
                    spotCanvas.height = targetHeight;
                    
                    originalImageData = reconstructImage(targetWidth, targetHeight, downscaledWidth, downscaledHeight, regressionCoefficients);
                    
                    regressionInfo.textContent = `Zrekonstruowany: ${targetWidth}x${targetHeight} (skalowany z danych regresji ${downscaledWidth}x${downscaledHeight}).`;


                    // Krok 5: Rysowanie i nałożenie plam
                    drawSpotsAndBlend(targetWidth, targetHeight, originalImageData);

                    statusMessage.textContent = "Przetwarzanie zakończone pomyślnie. Zrekonstruowany obraz jest gotowy.";
                    statusMessage.classList.remove('bg-yellow-100', 'text-yellow-800');
                    statusMessage.classList.add('bg-green-100', 'text-green-800');
                    processButton.disabled = false;
                    drawSpotsButton.disabled = false; 
                    displayCoefficients(regressionCoefficients);

                } catch (error) {
                    console.error("Wystąpił błąd w trakcie przetwarzania:", error);
                    statusMessage.textContent = `Błąd przetwarzania: ${error.message}`;
                    statusMessage.classList.remove('bg-green-100');
                    statusMessage.classList.add('bg-red-100', 'text-red-800');
                    processButton.disabled = false;
                    drawSpotsButton.disabled = true;
                }
            };
            
            img.onerror = () => {
                statusMessage.textContent = "Błąd: Nie udało się załadować obrazu.";
                statusMessage.classList.add('bg-red-100', 'text-red-800');
                processButton.disabled = false;
                drawSpotsButton.disabled = true;
            };

            img.src = URL.createObjectURL(file);
        }

        /**
         * Rekonstruuje obraz używając obliczonych współczynników, skalując do nowego rozmiaru.
         * @param {number} targetW Szerokość docelowa
         * @param {number} targetH Wysokość docelowa
         * @param {number} sourceW Szerokość źródłowa (z której pochodzą współrzędne regresji)
         * @param {number} sourceH Wysokość źródłowa
         * @param {{r: number[], g: number[], b: number[]}} coeffs Współczynniki [a0, a1, a2]
         * @returns {ImageData} Zrekonstruowane dane obrazu.
         */
        function reconstructImage(targetW, targetH, sourceW, sourceH, coeffs) {
            const newImageData = regressionCtx.createImageData(targetW, targetH);
            const newData = newImageData.data;

            const [r0, r1, r2] = coeffs.r;
            const [g0, g1, g2] = coeffs.g;
            const [b0, b1, b2] = coeffs.b;
            
            // Współczynniki skalowania do przeliczenia pikseli docelowych na współrzędne źródłowe dla regresji
            const scaleX = sourceW / targetW;
            const scaleY = sourceH / targetH;

            for (let y = 0; y < targetH; y++) {
                for (let x = 0; x < targetW; x++) {
                    const i = (y * targetW + x) * 4;
                    
                    // Skalowanie współrzędnych (x, y) do zakresu, dla którego policzono regresję
                    const rx = x * scaleX;
                    const ry = y * scaleY;

                    // Obliczanie nowej wartości koloru na podstawie regresji liniowej: C(rx, ry) = a0 + a1*rx + a2*ry
                    const R = Math.max(0, Math.min(255, r0 + r1 * rx + r2 * ry));
                    const G = Math.max(0, Math.min(255, g0 + g1 * rx + g2 * ry));
                    const B = Math.max(0, Math.min(255, b0 + b1 * rx + b2 * ry));

                    newData[i] = Math.round(R);
                    newData[i + 1] = Math.round(G);
                    newData[i + 2] = Math.round(B);
                    newData[i + 3] = 255;
                }
            }
            
            return newImageData;
        }

        /**
         * Wyświetla obliczone współczynniki.
         */
        function displayCoefficients(coeffs) {
            const output = `
Coefficients for R (C(x, y) = a₀ + a₁x + a₂y):
  a₀: ${coeffs.r[0].toFixed(4)}
  a₁: ${coeffs.r[1].toFixed(4)}
  a₂: ${coeffs.r[2].toFixed(4)}

Coefficients for G:
  a₀: ${coeffs.g[0].toFixed(4)}
  a₁: ${coeffs.g[1].toFixed(4)}
  a₂: ${coeffs.g[2].toFixed(4)}

Coefficients for B:
  a₀: ${coeffs.b[0].toFixed(4)}
  a₁: ${coeffs.b[1].toFixed(4)}
  a₂: ${coeffs.b[2].toFixed(4)}
            `;
            coeffPre.textContent = output;
            coefficientsDiv.classList.remove('hidden');
        }

        // --- LOGIKA RYSOWANIA I MIESZANIA PLAM TLC ---

        /**
         * Rysuje plamy TLC na off-screen canvas i miesza z obrazem po regresji.
         * @param {number} w Szerokość (docelowa)
         * @param {number} h Wysokość (docelowa)
         * @param {ImageData} baseImageData Dane obrazu po regresji
         */
        function drawSpotsAndBlend(w, h, baseImageData) {
            try {
                spotCtx.clearRect(0, 0, w, h);
                spotCtx.globalCompositeOperation = 'source-over'; 
                
                const finalImageData = regressionCtx.createImageData(w, h);
                finalImageData.data.set(baseImageData.data);
                const finalData = finalImageData.data;

                const spotJson = spotDataTextarea.value.trim();
                let spots = [];
                if (spotJson) {
                    spots = JSON.parse(spotJson);
                }

                if (spots.length === 0) {
                    regressionCtx.putImageData(baseImageData, 0, 0);
                    return;
                }

                spots.forEach(spot => {
                    const { x, y, width, height, color, intensity } = spot;
                    
                    if (typeof x !== 'number' || typeof y !== 'number' || typeof width !== 'number' || typeof height !== 'number' || typeof intensity !== 'number' || !color) {
                         console.warn("Nieprawidłowy format plamy pominięty:", spot);
                         return;
                    }
                    
                    const drawIntensity = Math.max(0, Math.min(1, intensity));
                    
                    const px = x * w;
                    const py = y * h;
                    const pWidth = width * w;
                    const pHeight = height * h;
                    
                    spotCtx.beginPath();
                    spotCtx.ellipse(
                        px, // Środek X
                        py, // Środek Y
                        pWidth / 2, // Promień wzdłuż X
                        pHeight / 2, // Promień wzdłuż Y
                        0, // Kąt obrotu
                        0, // Kąt początkowy
                        2 * Math.PI // Kąt końcowy
                    );
                    
                    const r = parseInt(color.substring(1, 3), 16);
                    const g = parseInt(color.substring(3, 5), 16);
                    const b = parseInt(color.substring(5, 7), 16);
                    
                    spotCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${drawIntensity})`;
                    spotCtx.fill();
                });

                const spotImageData = spotCtx.getImageData(0, 0, w, h);
                const spotData = spotImageData.data;
                
                for (let i = 0; i < finalData.length; i += 4) {
                    const alpha = spotData[i + 3] / 255;
                    
                    if (alpha > 0) {
                        const spotR = spotData[i];
                        const spotG = spotData[i + 1];
                        const spotB = spotData[i + 2];
                        
                        const baseR = finalData[i];
                        const baseG = finalData[i + 1];
                        const baseB = finalData[i + 2];
                        
                        finalData[i] = Math.round(baseR * (1 - alpha) + spotR * alpha);
                        finalData[i + 1] = Math.round(baseG * (1 - alpha) + spotG * alpha);
                        finalData[i + 2] = Math.round(baseB * (1 - alpha) + spotB * alpha);
                    }
                }
                
                regressionCtx.putImageData(finalImageData, 0, 0);

                statusMessage.textContent = "Plamy TLC nałożone pomyślnie.";
                statusMessage.classList.remove('bg-yellow-100', 'text-yellow-800', 'bg-red-100', 'text-red-800');
                statusMessage.classList.add('bg-green-100', 'text-green-800');

            } catch (error) {
                console.error("Błąd podczas rysowania plam TLC:", error);
                statusMessage.textContent = `Błąd podczas rysowania plam TLC: ${error.message}. Sprawdź, czy JSON jest poprawny.`;
                statusMessage.classList.remove('bg-green-100');
                statusMessage.classList.add('bg-red-100', 'text-red-800');
            }
        }
        
        // Inicjalizacja Local Storage po załadowaniu skryptu
        initializeLocalStorage();
    </script>
</body>
</html>