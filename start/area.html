<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obraz z IndexedDB</title>
    <link rel="icon" href="/favicon-32x32.png" sizes="32x32" type="image/png">
    <link rel="icon" href="/favicon-64x64.png" sizes="64x64" type="image/png">
    <link rel="stylesheet" href="styles.css">
    <style>
        body { text-align: center; font-family: Arial, sans-serif; margin: 0; padding: 0; }
        #imageContainer { position: relative; width: 98%; overflow: hidden; margin-left: 1%; }
        #uploadedImage { width: 100%; display: none; }
        #overlay { position: absolute; border: 2px solid red; background: rgba(255, 165, 0, 0.25); pointer-events: none; }
        #controlsContainer { height: 15vh; overflow-y: scroll; margin-left: 5%; background: #f0f0f0; position: fixed; bottom: 10vh; width: 90%; opacity: 60%; }
        .sliderContainer { margin-bottom: 20px; }
        label { display: block; font-size: 18px; margin-bottom: 5px; }
        input[type="range"] { width: 100%; height: 35px; }
        #saveBtn { margin-top: 10px; font-size: 18px; padding: 10px 20px; cursor: pointer; }
        #output { width: 90%; margin-top: 10px; font-size: 16px; }
    </style>
</head>
<body>
    <h2>Obraz z IndexedDB</h2>
    <nav>
        <ul>
            <li><a href="/TLC/start/normalise.html">normalise</a></li>
            <li><a href="/TLC/start/settings.html">settings</a></li>
            <li><a href="/TLC">main menu</a></li>
        </ul>
    </nav>

    <div id="imageContainer">
        <img id="uploadedImage">
        <div id="overlay"></div>
    </div>

    <div id="controlsContainer">
        <div class="sliderContainer">
            <label>Top:</label>
            <input type="range" id="topSlider" min="0" max="100" value="20" step="0.05">
        </div>
        <br>
        <div class="sliderContainer">
            <label>Height:</label>
            <input type="range" id="heightSlider" min="10" max="100" value="50" step="0.05">
        </div>
        <br>
        <div class="sliderContainer">
            <label>Left:</label>
            <input type="range" id="leftSlider" min="0" max="100" value="20" step="0.05">
        </div>
        <br>
        <div class="sliderContainer">
            <label>Width:</label>
            <input type="range" id="widthSlider" min="10" max="100" value="50" step="0.05">
        </div>
        <br>
        <button id="saveBtn">Zapisz</button>
    </div>

    <div class="instruction">
        <h2>Instrukcja używania selekcji ścieżki</h2>
        <p>
          1. Użyj suwaków, aby zaznaczyć interesujący Cię obszar na obrazie. Możesz wybrać całą ścieżkę TLC lub tylko pojedynczą plamkę.  
        </p>
        <p>
          2. Kliknij przycisk <strong>Zapisz</strong>, aby potwierdzić wybór.  
        </p>
        <p class="note">
          Niezależnie od zaznaczonego fragmentu, w kolejnym kroku będziesz mógł wybrać dowolny tryb przetwarzania.  
          Ten etap służy jedynie do określenia części obrazu, którą chcesz analizować.  
        </p>
      </div>

    <script>
        let db;
        const nameBcg = 'averageImage_bcg';
        const uploadedImage = document.getElementById("uploadedImage");
        const overlay = document.getElementById("overlay");
        const topSlider = document.getElementById("topSlider");
        const heightSlider = document.getElementById("heightSlider");
        const leftSlider = document.getElementById("leftSlider");
        const widthSlider = document.getElementById("widthSlider");
        const saveBtn = document.getElementById("saveBtn");

        let naturalWidth = 1, naturalHeight = 1;

        // Open IndexedDB
        function openDB() {
            const request = indexedDB.open('ImageDB', 1);
            request.onsuccess = function(event) {
                db = event.target.result;
                loadImageFromDB();
            };
            request.onerror = function() {
                alert("Błąd podczas otwierania bazy danych.");
            };
        }

        // Load image from IndexedDB
        function loadImageFromDB() {
            const transaction = db.transaction(["images"], "readonly");
            const store = transaction.objectStore("images");
            const bcgRequest = store.get(nameBcg);

            bcgRequest.onsuccess = function() {
                if (bcgRequest.result) {
                    const blob = bcgRequest.result;
                    const url = URL.createObjectURL(blob);
                    uploadedImage.onload = function () {
                        naturalWidth = uploadedImage.naturalWidth;
                        naturalHeight = uploadedImage.naturalHeight;
                        uploadedImage.style.display = "block";
                        updateOverlay(true);
                    };
                    uploadedImage.src = url;
                } else {
                    alert("Nie znaleziono obrazu w bazie danych.");
                }
            };

            bcgRequest.onerror = function() {
                alert("Błąd podczas ładowania obrazu.");
            };
        }

        // Update overlay position and size
        function updateOverlay(mode) {
            if (mode) {
                fetchFromIndexedDB()
                .then(data => {
                    topSlider.value = data.top;
                    heightSlider.value = data.height;
                    leftSlider.value = data.left;
                    widthSlider.value = data.width;

                    const topPx = (topSlider.value / 100) * naturalHeight;
                    const heightPx = (heightSlider.value / 100) * naturalHeight;
                    const leftPx = (leftSlider.value / 100) * naturalWidth;
                    const widthPx = (widthSlider.value / 100) * naturalWidth;

                    overlay.style.top = (topPx * (uploadedImage.clientHeight / naturalHeight)) + "px";
                    overlay.style.height = (heightPx * (uploadedImage.clientHeight / naturalHeight)) + "px";
                    overlay.style.left = (leftPx * (uploadedImage.clientWidth / naturalWidth)) + "px";
                    overlay.style.width = (widthPx * (uploadedImage.clientWidth / naturalWidth)) + "px";        
                })
                .catch(error => console.error("Błąd:", error));
            }
            else{
                const topPx = (topSlider.value / 100) * naturalHeight;
                const heightPx = (heightSlider.value / 100) * naturalHeight;
                const leftPx = (leftSlider.value / 100) * naturalWidth;
                const widthPx = (widthSlider.value / 100) * naturalWidth;

                overlay.style.top = (topPx * (uploadedImage.clientHeight / naturalHeight)) + "px";
                overlay.style.height = (heightPx * (uploadedImage.clientHeight / naturalHeight)) + "px";
                overlay.style.left = (leftPx * (uploadedImage.clientWidth / naturalWidth)) + "px";
                overlay.style.width = (widthPx * (uploadedImage.clientWidth / naturalWidth)) + "px";      
            }
        }

        // Event listeners for sliders
        document.querySelectorAll("input[type='range']").forEach(slider => {
            slider.addEventListener("input", () => {updateOverlay(false)});
        });

        // Save data to IndexedDB
        saveBtn.addEventListener("click", function() {
            const topPercent = topSlider.value;
            const heightPercent = heightSlider.value;
            const leftPercent = leftSlider.value;
            const widthPercent = widthSlider.value;

            const pixelCoords = {
                top: Math.round((topPercent / 100) * naturalHeight),
                height: Math.round((heightPercent / 100) * naturalHeight),
                left: Math.round((leftPercent / 100) * naturalWidth),
                width: Math.round((widthPercent / 100) * naturalWidth)
            };

            const percentCoords = { top: topPercent, height: heightPercent, left: leftPercent, width: widthPercent };

            saveToDB("pixel_coords", pixelCoords);
            saveToDB("percental_coords", percentCoords);

            alert("Dane zapisane w IndexedDB!");
        });

        // Save to IndexedDB
        function saveToDB(key, value) {
            const request = indexedDB.open("ParametryDB", 1);
            request.onsuccess = function(event) {
                const db = event.target.result;
                const transaction = db.transaction("parametry", "readwrite");
                const store = transaction.objectStore("parametry");
                store.put(value, key);
            };
            request.onerror = function() {
                alert("Błąd podczas zapisywania danych.");
            };
        }

        // Fetch data from IndexedDB
        function fetchFromIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("ParametryDB", 1);
                request.onsuccess = function(event) {
                    const db = event.target.result;
                    const transaction = db.transaction("parametry", "readonly");
                    const store = transaction.objectStore("parametry");
                    const getRequest = store.get("percental_coords");

                    getRequest.onsuccess = function() {
                        if (getRequest.result) {
                            resolve(getRequest.result);
                        } else {
                            reject("Brak danych w bazie z tym kluczem");
                        }
                    };
                    getRequest.onerror = function(error) {
                        reject("Błąd podczas odczytu danych z IndexedDB: " + error.target.error);
                    };
                };
                request.onerror = function(error) {
                    reject("Błąd podczas otwierania bazy danych: " + error.target.error);
                };
            });
        }

        openDB();
    </script>
</body>
</html>
