<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas z IndexedDB</title>
    <script src="https://daybrush.com/moveable/release/latest/dist/moveable.min.js"></script>
    <link rel="stylesheet" href="pushdata.css">
    <style>
        canvas{
            border: solid black 1px;
        }

        #canvas_space{
            display: none;
        }
    </style>
</head>
<body>
    <script>
        // starter script
        function setBodyClassBasedOnScreenSize() {
            const dpi = window.devicePixelRatio || 1;
            const screenWidthInches = (window.innerWidth / dpi) / 96; // 96 dpi as standard
            const screenHeightInches = (window.innerHeight / dpi) / 96;
            const screenDiagonalInches = Math.sqrt(Math.pow(screenWidthInches, 2) + Math.pow(screenHeightInches, 2));
            const screenDiagonalMM = screenDiagonalInches * 25.4; // Convert inches to millimeters
            
            document.body.classList.remove("small-screen", "medium-screen", "large-screen");
            
            if (screenDiagonalMM < 180) { 
                document.body.classList.add("small-screen");
            } else if (screenDiagonalMM >= 180 && screenDiagonalMM < 330) { 
                document.body.classList.add("medium-screen");
            } else {
                document.body.classList.add("large-screen");
            }
        }
        window.onresize = setBodyClassBasedOnScreenSize;
        setBodyClassBasedOnScreenSize();
    </script>

    <div class="controls">
        <h3 id="konsola">konsola: </h3>
        <label for="treshold" title="Ustaw pr√≥g powy≈ºej kt√≥rego piksele bƒôdƒÖ zaliczone do t≈Ça i wybielone">Pr√≥g</label>
        <input type="number" id="treshold" min="0" max="255" step="1" value="240">
        <label for="kernelSize" title="Kernel dla blurr - do wykrywania granic peaku">blur</label>
        <input type="number" id="kernelSize" min="1" max="20" step="1" value="5">
        <button onclick="autostart()" title="Ponowne przetwarzanie danych po korekcie">üîÑ</button>
        <button onclick="unselectElement()" title="Odznacz wybrany element">‚ùå</button>
        <button onclick="removeSelectedElement()" title="Usu≈Ñ wybrany element">üóëÔ∏è</button>
        <button onclick="addDraggableElement()" title="Utw√≥rz nowƒÖ ≈õcie≈ºkƒô">‚ûï</button>
        <button id="toggleBtn" title="Poka≈º/Ukryj obszar rysowania" onclick="toggle_CanvasSpace()">‚áÑ</button>
    </div>
    <div id="canvas_space">
        <h2>Spots image</h2>
        <canvas id="spots" width="400" height="400"></canvas>

        <h2>Background image</h2>
        <canvas id="background" width="400" height="400"></canvas>

        <h2>Normalised Canvas</h2>
        <canvas id="normalised" width="400" height="400"></canvas>
    </div> 
    <!-- internalize script --><script src="internalize.js"></script><!-- internalize script -->

    <script>
        // Zmienne globalne
        let baselines = null;
        let draggable_coordinates = null;
        let selectedTrack = null;
        let manuals = false;

        function toggle_CanvasSpace(){
            const canvasSpace = document.getElementById("canvas_space");
            canvasSpace.style.display = (canvasSpace.style.display === "none") ? "block" : "none";
        }

        // Funkcja do pobrania i parsowania danych JSON z IndexedDB
        function loadJsonDataFromIndexedDB(dbName, storeName, key) {
            return new Promise((resolve, reject) => {
                // Pobierz dane JSON z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((jsonData) => {
                    try {
                        // Parsowanie danych JSON
                        const parsedData = JSON.parse(jsonData);
                        console.log(parsedData);
                        // Przypisanie danych do odpowiednich zmiennych globalnych
                        if (key === "baselines") {
                            baselines = parsedData;
                        } else if (key === "draggable_coordinates") {
                            draggable_coordinates = parsedData;
                        }

                        // Zwr√≥ƒá Promise po udanym za≈Çadowaniu
                        resolve();
                    } catch (error) {
                        reject(`B≈ÇƒÖd podczas parsowania danych JSON: ${error}`);
                    }
                }).catch((error) => {
                    console.error('B≈ÇƒÖd podczas ≈Çadowania danych z IndexedDB:', error);
                    reject(error);
                });
            });
        }

        // Funkcja do wstawienia obrazu na odpowiedni canvas
        function loadImageToCanvas(dbName, storeName, key, canvasId) {
            return new Promise((resolve, reject) => {
                // Pobierz URL obrazu z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((imageUrl) => {
                    // Znajd≈∫ odpowiedni element canvas
                    const canvas = document.getElementById(canvasId);
                    if (canvas && imageUrl) {
                        const img = new Image();
                        img.onload = () => {
                            // Ustaw rozmiar canvasu na rozmiar obrazu
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // Rysuj obraz na canvas
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(img, 0, 0);  // Wstaw obraz na canvas

                            // Zwr√≥ƒá Promise po za≈Çadowaniu obrazu
                            resolve();
                        };
                        img.src = imageUrl;  // Ustaw ≈∫r√≥d≈Ço obrazu
                    } else {
                        reject('B≈ÇƒÖd przy ≈Çadowaniu obrazu.');
                    }
                }).catch((error) => {
                    console.error('B≈ÇƒÖd podczas ≈Çadowania obrazu:', error);
                    reject(error);
                });
            });
        }

        // Funkcja, kt√≥ra ma byƒá uruchomiona po za≈Çadowaniu obu obraz√≥w
        function onAllDataLoaded() {
            normalizeCanvasData();
            extractTrackData(draggable_coordinates, baselines);
        }

        function autostart() {
            const dbName = "TLC";
            const storeName = "data";

            // ≈Åadowanie obu obraz√≥w jednocze≈õnie
            Promise.all([
                loadImageToCanvas(dbName, storeName, "spots", "spots"),
                loadImageToCanvas(dbName, storeName, "background", "background"),
                loadJsonDataFromIndexedDB(dbName, storeName, "baselines"),
                loadJsonDataFromIndexedDB(dbName, storeName, "draggable_coordinates")
            ]).then(() => {
                // Po za≈Çadowaniu obu obraz√≥w uruchom funkcjƒô
                onAllDataLoaded();
            }).catch((error) => {
                console.error("WystƒÖpi≈Ç b≈ÇƒÖd podczas ≈Çadowania obraz√≥w:", error);
            });            
        }

        // ≈Åadowanie obraz√≥w na kanwasy po za≈Çadowaniu strony
        window.onload = () => {
            autostart();
        };

        function normalizeCanvasData() {
            // Pobierz referencje do canvas√≥w
            const spotsCanvas = document.getElementById("spots");
            const backgroundCanvas = document.getElementById("background");

            // Sprawd≈∫, czy oba canvas majƒÖ takie same wymiary
            if (spotsCanvas.width !== backgroundCanvas.width || spotsCanvas.height !== backgroundCanvas.height) {
                alert("Canvas majƒÖ r√≥≈ºne wymiary! Upewnij siƒô, ≈ºe oba canvas majƒÖ te same wymiary.");
                return;
            }

            // Pobierz ImageData z obu canvas√≥w
            const spotsContext = spotsCanvas.getContext("2d");
            const backgroundContext = backgroundCanvas.getContext("2d");

            const spotsImageData = spotsContext.getImageData(0, 0, spotsCanvas.width, spotsCanvas.height);
            const backgroundImageData = backgroundContext.getImageData(0, 0, backgroundCanvas.width, backgroundCanvas.height);

            // Przygotuj nowy canvas na wynik
            const normalizedCanvas = document.getElementById("normalised");
            normalizedCanvas.width = spotsCanvas.width;
            normalizedCanvas.height = spotsCanvas.height;
            const normalizedContext = normalizedCanvas.getContext("2d");
            const normalizedImageData = normalizedContext.createImageData(spotsCanvas.width, spotsCanvas.height);

            const treshold = parseInt(document.getElementById('treshold').value);
            // Przetw√≥rz piksel po pikselu
            for (let i = 0; i < spotsImageData.data.length; i += 4) {
                const rSpots = spotsImageData.data[i];     // Czerwony kana≈Ç z spots
                const rBackground = backgroundImageData.data[i]; // Czerwony kana≈Ç z background

                // Podziel kana≈Ç czerwony spots przez kana≈Ç czerwony background i przemn√≥≈º przez 255
                let rNormalized;
                if (rBackground === 0) {
                    rNormalized = 255; // Unikaj dzielenia przez zero
                } else {
                    rNormalized = (rSpots / rBackground) * 255;
                }

                // Ustaw ograniczenie na warto≈õƒá z input
                rNormalized = rNormalized > treshold ? 255 : rNormalized;

                // Ustaw wynik dla wszystkich kana≈Ç√≥w (RGB)
                normalizedImageData.data[i] = rNormalized;        // R
                normalizedImageData.data[i + 1] = rNormalized;    // G
                normalizedImageData.data[i + 2] = rNormalized;    // B
                normalizedImageData.data[i + 3] = 255;            // A (pe≈Çna przezroczysto≈õƒá)
            }

            // Wstaw ImageData do canvasu "normalised"
            normalizedContext.putImageData(normalizedImageData, 0, 0);
        }

        // Function to blur an array using a kernel size
        function blurArray(inputArray, kernelSize) {
            const outputArray = new Array(inputArray.length).fill(0);
            const halfKernel = Math.floor(kernelSize / 2);

            for (let i = 0; i < inputArray.length; i++) {
                let sum = 0;
                let count = 0;

                for (let k = -halfKernel; k <= halfKernel; k++) {
                    const idx = i + k;
                    if (idx >= 0 && idx < inputArray.length) {
                        sum += inputArray[idx];
                        count++;
                    }
                }
                if (inputArray[i] === 0) {
                outputArray[i] = 0;
                }
                else{
                outputArray[i] = sum / count;
                }
            }
            return outputArray;
        }

        function analyzeArrayWithKernel(array, kernelSize, height) {
            const mountains = [];
            let status = "constant"; // Possible values: "constant", "ascending", "descending"
            let mountainStart = null;
            let mountainEnd = null;

            for (let i = 0; i < array.length; i++) {
                // Get neighbors to the right based on kernel size
                const neighbors = [];
                for (let k = 1; k <= kernelSize; k++) {
                    if (i + k < array.length) {
                        neighbors.push(array[i + k]);
                    }
                }

                // Calculate the average of neighbors
                const average = neighbors.length > 0 
                    ? neighbors.reduce((sum, val) => sum + val, 0) / neighbors.length
                    : 0;

                // Determine the new status based on comparison with average
                let newStatus;
                if (array[i] > average) {
                    newStatus = "descending";
                } else if (array[i] < average) {
                    newStatus = "ascending";
                } else {
                    newStatus = "constant";
                }

                // Handle status change logic
                if (newStatus !== status) {
                    if ((status === "constant" || status === "descending") && newStatus === "ascending" ) {
                    if (mountainStart !== null) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = i;
                        mountainEnd = null;                
                    }
                    else{
                        mountainStart = mountainStart === null ? i : mountainStart;
                    }
                        
                    } 
                    else if (status === "descending" && mountainStart !== null && (newStatus === "constant" )) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = null;
                        mountainEnd = null;
                    }          

                    // Update status
                    //console.log(status, newStatus);
                    status = newStatus;
                    
                }
            }
            // Find the global minimum and maximum values in arr
            const globalMin = Math.min(...array);
            const globalMax = Math.max(...array);
            const globalDistance = globalMax - globalMin;
            // Validate and extract real mountains
            const realMountains = mountains.filter(({ start, end }) => {
            const fragment = array.slice(start, end + 1); // Get the fragment of arr
            const fragmentMin = Math.min(...fragment);
            const fragmentMax = Math.max(...fragment);
            const fragmentDistance = fragmentMax - fragmentMin;

            // Compare fragment distance to x% of global distance
            return fragmentDistance >= (height / 100) * globalDistance;
            });
            return realMountains;
        }

        function extractTrackData(draggable_coordinates, baselines) {
            // Uzyskanie dostƒôpu do g≈Ç√≥wnego canvas
            const mainCanvas = document.getElementById('normalised');
            const mainCtx = mainCanvas.getContext('2d');
            const kernelSize = parseInt(document.getElementById('kernelSize').value);
            draggable_coordinates.forEach(coordinate => {
                // Wydobywanie danych z ImageData dla podanych wsp√≥≈Çrzƒôdnych
                const imageData = mainCtx.getImageData(baselines.x, coordinate.y, baselines.width, coordinate.height);
                // Tworzenie nowego canvas i kontekstu
                const newCanvas = document.createElement('canvas');
                const newCtx = newCanvas.getContext('2d');

                // Ustawianie rozmiaru nowego canvas
                newCanvas.width = baselines.width;
                newCanvas.height = coordinate.height;

                // Wstawianie ImageData do nowego canvas
                newCtx.putImageData(imageData, 0, 0);

                // Tworzenie nowego div'a z odpowiednim id
                const newDiv = document.createElement('div');
                newDiv.style.position = 'relative';
                newDiv.id = coordinate.name;  // Ustawianie id div'a na podstawie 'name' w draggable_coordinates

                // Tworzenie tablicy 1D z sumami kana≈Çu czerwonego dla ka≈ºdej kolumny
                const RedSums = [];
                for (let x = 0; x < imageData.width; x++) {
                    let sumRed = 0;
                    for (let y = 0; y < imageData.height; y++) {
                        const index = (y * imageData.width + x) * 4;
                        sumRed += 255 - imageData.data[index]; // Kana≈Ç czerwony to pierwszy element w tablicy (index * 4)
                    }

                    RedSums.push(sumRed); // Zapisanie sumy kana≈Çu czerwonego dla ka≈ºdej kolumny
                }
                
                const blurredRedSums = blurArray(RedSums, kernelSize);
                const mountains = analyzeArrayWithKernel(blurredRedSums, 1, 1);
                console.log(mountains);
                // Normalizacja RedSums (zak≈ÇadajƒÖc, ≈ºe minimalna warto≈õƒá to 0, a maksymalna to 250)
                const min = Math.min(...RedSums);
                const max = Math.max(...RedSums);
                const normalizedRedSums = RedSums.map(value => (value - min) / (max - min) * 250);
                
                // Dodanie atrybutu data-red-sums do div'a z 1D tablicƒÖ RedSums
                newDiv.dataset.RedSums = JSON.stringify(RedSums);  // U≈ºycie data-* atrybutu
                newDiv.dataset.blurRedredSums = JSON.stringify(blurredRedSums); 
                // Tworzenie g≈Ç√≥wnego canvas
                const mainCanvas = document.createElement('canvas');
                mainCanvas.width = newCanvas.width;
                mainCanvas.height = 250;
                const ctx = mainCanvas.getContext('2d');

                // Rysowanie wykresu jako linia
                ctx.beginPath();
                ctx.strokeStyle = 'steelblue';
                ctx.lineWidth = 2;
                normalizedRedSums.forEach((value, index) => {
                    const x = (index / (normalizedRedSums.length - 1)) * mainCanvas.width;
                    const y = 250 - value;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                const header = document.createElement('h2');
                header.textContent = coordinate.name;
                newDiv.appendChild(header);
                // Dodanie canvas z wykresem do div'a
                newDiv.appendChild(mainCanvas);

                // Dodanie br pomiƒôdzy canvasami
                const br = document.createElement('br');
                newDiv.appendChild(br);

                // Dodanie canvas do div'a
                newDiv.appendChild(newCanvas);

                // Dodanie div'a do dokumentu (np. do body)
                document.body.appendChild(newDiv);

                // Pobranie pozycji newDiv
                const newDivRect = newDiv.getBoundingClientRect();
                const mainCanvasRect = mainCanvas.getBoundingClientRect();
                const newCanvasRect = newCanvas.getBoundingClientRect();

                // Obliczenie wysoko≈õci od g√≥ry mainCanvas do do≈Çu newCanvas wzglƒôdem newDiv
                const totalHeight = newCanvasRect.bottom - mainCanvasRect.top;

                // Tworzenie div√≥w dla ka≈ºdego obiektu w mountains
                mountains.forEach(({ start, end }) => {
                    const mountainDiv = document.createElement('div');
                    
                    mountainDiv.style.position = 'absolute';
                    mountainDiv.style.left = `${start - newDivRect.left}px`;  // Wzglƒôdem newDiv
                    mountainDiv.style.width = `${end - start}px`;
                    mountainDiv.style.top = `${mainCanvasRect.top - newDivRect.top}px`; // Wzglƒôdem newDiv
                    mountainDiv.style.height = `${totalHeight}px`;
                    mountainDiv.style.backgroundColor = 'rgba(0, 0, 255, 0.3)'; // Przezroczysty kolor dla widoczno≈õci

                    newDiv.appendChild(mountainDiv);
                    createDraggableElement(newDiv, mountainDiv);
                });

            });
        }

        function addDraggableElement() {
            const element = selectedTrack.target;
            const container = element.parentElement;
            //const RectContainer = container.getBoundingClientRect();
            const mountainDiv = document.createElement('div');
                    
            mountainDiv.style.position = 'absolute';
            mountainDiv.style.left = element.style.left;
            mountainDiv.style.width = element.style.width;
            mountainDiv.style.top = element.style.top;
            mountainDiv.style.height = element.style.height;
            mountainDiv.style.backgroundColor = 'rgba(0, 0, 255, 0.3)'; // Przezroczysty kolor dla widoczno≈õci
            container.appendChild(mountainDiv);
            createDraggableElement(container, mountainDiv);
        }

        // Moveable setup
        function createDraggableElement(container, element) {
            if (!container) return;
            const containerHeight = container.getBoundingClientRect().height;
            element.classList.add("draggable");
            
            const movable = new Moveable(container, {
                target: element,
                draggable: true,
                throttleDrag: 1,
                edgeDraggable: false,
                startDragRotate: 0,
                throttleDragRotate: 0,
                resizable: true,
                keepRatio: false,
                throttleResize: 1,
                renderDirections:  ["w", "e"],
                bounds: { left: 0, right: 0 }        
            });
            movable.on("drag", e => {
                e.target.style.left = `${e.left}px`;
            });
            movable.on("resize", e => {
                e.target.style.width = `${e.width}px`;
                e.target.style.transform = e.drag.transform;
            });
            movable.on("click", e => {
                resetDraggablesColor();
                selectedTrack = {target: e.target, moveable: e.moveable};
                e.target.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            });
        }

        function resetDraggablesColor() {
            document.querySelectorAll(".draggable").forEach(el => {
                el.style.backgroundColor = 'rgba(0, 0, 255, 0.3)';
            });
        }

        function unselectElement(){
            selectedTrack = null;
            resetDraggablesColor();
        }

        function removeSelectedElement() {
            if (selectedTrack) {
                selectedTrack.moveable.controlBox.remove();
                selectedTrack.moveable.destroy();
                selectedTrack.target.remove();
                selectedTrack = null;
            }
        }

    </script>     
</body>
</html>
