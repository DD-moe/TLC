<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas z IndexedDB</title>
    <script src="https://daybrush.com/moveable/release/latest/dist/moveable.min.js"></script>
    <link rel="stylesheet" href="pushdata.css">
</head>
<body>
    <script>
        // starter script
        function setBodyClassBasedOnScreenSize() {
            const dpi = window.devicePixelRatio || 1;
            const screenWidthInches = (window.innerWidth / dpi) / 96; // 96 dpi as standard
            const screenHeightInches = (window.innerHeight / dpi) / 96;
            const screenDiagonalInches = Math.sqrt(Math.pow(screenWidthInches, 2) + Math.pow(screenHeightInches, 2));
            const screenDiagonalMM = screenDiagonalInches * 25.4; // Convert inches to millimeters
            
            document.body.classList.remove("small-screen", "medium-screen", "large-screen");
            
            if (screenDiagonalMM < 180) { 
                document.body.classList.add("small-screen");
            } else if (screenDiagonalMM >= 180 && screenDiagonalMM < 330) { 
                document.body.classList.add("medium-screen");
            } else {
                document.body.classList.add("large-screen");
            }
        }
        window.onresize = setBodyClassBasedOnScreenSize;
        setBodyClassBasedOnScreenSize();
    </script>

    <div class="controls">
        <h3 id="konsola">konsola: </h3>
        <label for="treshold" title="Ustaw próg powyżej którego piksele będą zaliczone do tła i wybielone">Próg</label>
        <input type="range" id="treshold" min="0" max="255" step="1" value="240">
        <button onclick="autostart()" title="Ponowne przetwarzanie danych po korekcie">🔄</button>
    </div>
    <h2>Spots image</h2>
    <canvas id="spots" width="400" height="400"></canvas>

    <h2>Background image</h2>
    <canvas id="background" width="400" height="400"></canvas>

    <h2>Normalised Canvas</h2>
    <canvas id="normalised" width="400" height="400"></canvas>

    <!-- internalize script --><script src="internalize.js"></script><!-- internalize script -->

    <script>
        // Zmienne globalne
        let baselines = null;
        let draggable_coordinates = null;

        // Funkcja do pobrania i parsowania danych JSON z IndexedDB
        function loadJsonDataFromIndexedDB(dbName, storeName, key) {
            return new Promise((resolve, reject) => {
                // Pobierz dane JSON z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((jsonData) => {
                    try {
                        // Parsowanie danych JSON
                        const parsedData = JSON.parse(jsonData);

                        // Przypisanie danych do odpowiednich zmiennych globalnych
                        if (key === "baselines") {
                            baselines = parsedData;
                        } else if (key === "draggable_coordinates") {
                            draggable_coordinates = parsedData;
                        }

                        // Zwróć Promise po udanym załadowaniu
                        resolve();
                    } catch (error) {
                        reject(`Błąd podczas parsowania danych JSON: ${error}`);
                    }
                }).catch((error) => {
                    console.error('Błąd podczas ładowania danych z IndexedDB:', error);
                    reject(error);
                });
            });
        }

        // Funkcja do wstawienia obrazu na odpowiedni canvas
        function loadImageToCanvas(dbName, storeName, key, canvasId) {
            return new Promise((resolve, reject) => {
                // Pobierz URL obrazu z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((imageUrl) => {
                    // Znajdź odpowiedni element canvas
                    const canvas = document.getElementById(canvasId);
                    if (canvas && imageUrl) {
                        const img = new Image();
                        img.onload = () => {
                            // Ustaw rozmiar canvasu na rozmiar obrazu
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // Rysuj obraz na canvas
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(img, 0, 0);  // Wstaw obraz na canvas

                            // Zwróć Promise po załadowaniu obrazu
                            resolve();
                        };
                        img.src = imageUrl;  // Ustaw źródło obrazu
                    } else {
                        reject('Błąd przy ładowaniu obrazu.');
                    }
                }).catch((error) => {
                    console.error('Błąd podczas ładowania obrazu:', error);
                    reject(error);
                });
            });
        }

        // Funkcja, która ma być uruchomiona po załadowaniu obu obrazów
        function onAllDataLoaded() {
            normalizeCanvasData();
        }

        function autostart() {
            const dbName = "TLC";
            const storeName = "data";

            // Ładowanie obu obrazów jednocześnie
            Promise.all([
                loadImageToCanvas(dbName, storeName, "spots", "spots"),
                loadImageToCanvas(dbName, storeName, "background", "background"),
                loadJsonDataFromIndexedDB(dbName, storeName, "baselines"),
                loadJsonDataFromIndexedDB(dbName, storeName, "draggable_coordinates")
            ]).then(() => {
                // Po załadowaniu obu obrazów uruchom funkcję
                onAllDataLoaded();
            }).catch((error) => {
                console.error("Wystąpił błąd podczas ładowania obrazów:", error);
            });            
        }

        // Ładowanie obrazów na kanwasy po załadowaniu strony
        window.onload = () => {
            autostart();
        };

        function normalizeCanvasData() {
            // Pobierz referencje do canvasów
            const spotsCanvas = document.getElementById("spots");
            const backgroundCanvas = document.getElementById("background");

            // Sprawdź, czy oba canvas mają takie same wymiary
            if (spotsCanvas.width !== backgroundCanvas.width || spotsCanvas.height !== backgroundCanvas.height) {
                alert("Canvas mają różne wymiary! Upewnij się, że oba canvas mają te same wymiary.");
                return;
            }

            // Pobierz ImageData z obu canvasów
            const spotsContext = spotsCanvas.getContext("2d");
            const backgroundContext = backgroundCanvas.getContext("2d");

            const spotsImageData = spotsContext.getImageData(0, 0, spotsCanvas.width, spotsCanvas.height);
            const backgroundImageData = backgroundContext.getImageData(0, 0, backgroundCanvas.width, backgroundCanvas.height);

            // Przygotuj nowy canvas na wynik
            const normalizedCanvas = document.getElementById("normalised");
            normalizedCanvas.width = spotsCanvas.width;
            normalizedCanvas.height = spotsCanvas.height;
            const normalizedContext = normalizedCanvas.getContext("2d");
            const normalizedImageData = normalizedContext.createImageData(spotsCanvas.width, spotsCanvas.height);

            const treshold = parseInt(document.getElementById('treshold').value);
            // Przetwórz piksel po pikselu
            for (let i = 0; i < spotsImageData.data.length; i += 4) {
                const rSpots = spotsImageData.data[i];     // Czerwony kanał z spots
                const rBackground = backgroundImageData.data[i]; // Czerwony kanał z background

                // Podziel kanał czerwony spots przez kanał czerwony background i przemnóż przez 255
                let rNormalized;
                if (rBackground === 0) {
                    rNormalized = 255; // Unikaj dzielenia przez zero
                } else {
                    rNormalized = (rSpots / rBackground) * 255;
                }

                // Ustaw ograniczenie na wartość z input
                rNormalized = Math.min(treshold, Math.max(0, rNormalized));

                // Ustaw wynik dla wszystkich kanałów (RGB)
                normalizedImageData.data[i] = rNormalized;        // R
                normalizedImageData.data[i + 1] = rNormalized;    // G
                normalizedImageData.data[i + 2] = rNormalized;    // B
                normalizedImageData.data[i + 3] = 255;            // A (pełna przezroczystość)
            }

            // Wstaw ImageData do canvasu "normalised"
            normalizedContext.putImageData(normalizedImageData, 0, 0);
        }


    </script>     
</body>
</html>
