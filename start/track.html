<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Damian Bezara, Karol Wróblewski">
    <meta name="creator" content="Damian Bezara">
    <meta name="keywords" content="TLC, chromatography, analysis, Damian Bezara, Karol Wróblewski, chemical analysis, quantitative analysis, open-source">
    <title>Track analysis</title>
    <script src="https://daybrush.com/moveable/release/latest/dist/moveable.min.js"></script>
    <link rel="stylesheet" href="pushdata.css">
    <link rel="icon" href="/TLC/favicon-32x32.png" sizes="32x32" type="image/png">
    <link rel="icon" href="/TLC/favicon-64x64.png" sizes="64x64" type="image/png">
    <style>
        canvas{
            border: solid black 1px;
        }

        #canvas_space{
            display: none;
        }

        #parameterBox ul {
            list-style-type: none; /* Usunięcie domyślnych kropek */
            padding: 0;
            margin: 0;
            width: 100%;
        }

        #parameterBox li {
            display: flex;
            justify-content: space-between; /* Rozdziela label i input */
            align-items: center;
            padding: 5px 10px;
            border-bottom: 1px solid #ddd; /* Opcjonalna linia oddzielająca */
        }

        #parameterBox label {
            flex: 1; /* Pozwala na dynamiczne dostosowanie szerokości */
            text-align: left;
            font-weight: bold;
        }

        #parameterBox input {
            flex: 0.5; /* Mniejsza szerokość dla inputa */
            text-align: right;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 80px; /* Stała szerokość inputa */
        }

    </style>
</head>
<body>
    <script>
        // starter script
        function setBodyClassBasedOnScreenSize() {
            const dpi = window.devicePixelRatio || 1;
            const screenWidthInches = (window.innerWidth / dpi) / 96; // 96 dpi as standard
            const screenHeightInches = (window.innerHeight / dpi) / 96;
            const screenDiagonalInches = Math.sqrt(Math.pow(screenWidthInches, 2) + Math.pow(screenHeightInches, 2));
            const screenDiagonalMM = screenDiagonalInches * 25.4; // Convert inches to millimeters
            
            document.body.classList.remove("small-screen", "medium-screen", "large-screen");
            
            if (screenDiagonalMM < 180) { 
                document.body.classList.add("small-screen");
            } else if (screenDiagonalMM >= 180 && screenDiagonalMM < 330) { 
                document.body.classList.add("medium-screen");
            } else {
                document.body.classList.add("large-screen");
            }
        }
        window.onresize = setBodyClassBasedOnScreenSize;
        setBodyClassBasedOnScreenSize();
    </script>

    <div class="controls">
        <h3 id="konsola">🔳: </h3>
        <label for="treshold" title="Set the threshold above which pixels will be considered as background and whitened">📊</label>
        <input type="number" id="treshold" min="0" max="255" step="1" value="240">
        <label for="kernelSize" title="Kernel for blurr - for detecting peak boundaries">🌫️</label>
        <input type="number" id="kernelSize" min="1" max="20" step="1" value="5">
        <input type="checkbox" id="showBlurr" title="!!! Blurr is only used for boundary detection; the raw data is used for the rest of the calculations">
        <button onclick="autostart()" title="Reprocessing data after correction">🔄</button>
        <button onclick="unselectElement()" title="Deselect the selected item">❌</button>
        <button onclick="removeSelectedElement()" title="Delete selected item">🗑️</button>
        <button onclick="addDraggableElement()" title="Create a new peak">➕</button>
        <button id="toggleBtn" title="Show/Hide Drawing Area" onclick="toggle_CanvasSpace()">⇄</button>
        <button id="calculate" title="Recalculate" onclick="countParams()">🔢</button>
        <button onclick="addConcentration()" title="Add a concentration measurement">➕🧪</button>
        <button onclick="clearConcentration()" title="Clear all concentrations data">🗑️🧪</button>
        <button onclick="saveParameterValues()" title="Save changes to peak">💾🧪</button>
        <button onclick="calculateLinearRegression()" title="Create a concentration curve">📈</button>
        <button onclick="PreparePositionalCurve()" title="Create a normalization curve">〰️</button> 
        <button onclick="getSpotReference()" title="Use as a concentration reference">🎯</button>
        <button onclick="copyImage()" title="copy the image of the charts to the report">📤🖼️</button>
        <button onclick="copyData()" title="report preview">📤𝄜</button>
        <div id="LinearRegression"></div>
        <div id="surfaceRef"></div>
        <a href="normaliser.html" title="light equalization panel">3️⃣🔧</a>
        <a href="setting.html" title="settings">⚙️</a>
        <a href="../index.html" title="home">🏠</a>
    </div>
    <div id="canvas_space">
        <h2>Spots image</h2>
        <canvas id="spots" width="400" height="400"></canvas>

        <h2>Background image</h2>
        <canvas id="background" width="400" height="400"></canvas>

        <h2>Normalised Canvas</h2>
        <canvas id="normalised" width="400" height="400"></canvas>
    </div>
    <div id="track_space"></div>
    <div id="parameterBox"></div>
    <div id="concentration_dataset"></div>

    </div> 
    <!-- internalize script --><script src="internalize.js"></script><!-- internalize script -->
    <!-- datapush script --><script src="datapush.js"></script><!-- datapush script -->
    <!-- screenshot script --><script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>


    <script>
        // Zmienne globalne
        let baselines = null;
        let draggable_coordinates = null;
        let selectedTrack = null;
        let manuals = false;
        let concentrationData = [];
        let referenceSurface = 1;
        let normalizationParams = {};

        // obiekt z alternatywnymi nazwami
        const namingConvention = {
            "PN": {
                abbv: "P<sub>N</sub>",
                desc: "Peak Name"
            },
            "TN": {
                abbv: "T<sub>N</sub>",
                desc: "Track Name"
            },
            "SM5": {
                abbv: "SM<sub>5</sub>",
                desc: "Startpoint to Midpoint Distance at 5% of Height"
            },
            "SM10": {
                abbv: "SM<sub>10</sub>",
                desc: "Startpoint to Midpoint Distance at 10% of Height"
            },
            "AS": {
                abbv: "A<sub>S</sub>",
                desc: "Asymmetry Factor"
            },
            "ME5": {
                abbv: "ME<sub>5</sub>",
                desc: "Midpoint to Endpoint Distance at 5% of Height"
            },
            "ME10": {
                abbv: "ME<sub>10</sub>",
                desc: "Midpoint to Endpoint Distance at 10% of Height"
            },
            "C": {
                abbv: "C",
                desc: "Substance Concentration"
            },
            "HETPEP": {
                abbv: "HETP<sub>EP</sub>",
                desc: "Height Equivalent to a Theoretical Plate - European Pharmacopeia"
            },
            "HETPUSP": {
                abbv: "HETP<sub>USP</sub>",
                desc: "Height Equivalent to a Theoretical Plate - United States Pharmacopeia"
            },
            "k": {
                abbv: "k",
                desc: "Capacity Factor"
            },
            "HTrack": {
                abbv: "H<sub>Track</sub>",
                desc: "Maximal Height on Track"
            },
            "STrack": {
                abbv: "S<sub>Track</sub>",
                desc: "Greatest Peak Surface for Track"
            },
            "MI": {
                abbv: "M<sub>I</sub>",
                desc: "Midpoint Index"
            },
            "NEP/m": {
                abbv: "N<sub>EP</sub>/m",
                desc: "Number of Theoretical Plates per meter - European Pharmacopeia"
            },
            "NUSP/m": {
                abbv: "N<sub>USP</sub>/m",
                desc: "Number of Theoretical Plates per meter - United States Pharmacopeia"
            },
            "NEP": {
                abbv: "N<sub>EP</sub>",
                desc: "Number of Theoretical Plates - European Pharmacopeia"
            },
            "NUSP": {
                abbv: "N<sub>USP</sub>",
                desc: "Number of Theoretical Plates - United States Pharmacopeia"
            },
            "H": {
                abbv: "H",
                desc: "Peak Height"
            },
            "H%": {
                abbv: "H<sub>%</sub>",
                desc: "Peak Height to Track Height Ratio"
            },
            "S%": {
                abbv: "S<sub>%</sub>",
                desc: "Peak Surface to Track Surface Ratio"
            },
            "PlW": {
                abbv: "Pl<sub>W</sub>",
                desc: "Plate Width in cm"
            },
            "RF": {
                abbv: "R<sub>F</sub>",
                desc: "Retardation Factor"
            },
            "RMLog10": {
                abbv: "R<sub>M</sub>",
                desc: "Logarithmic Retention Factor"
            },
            "S": {
                abbv: "S",
                desc: "Spot Area"
            },
            "TF": {
                abbv: "T<sub>F</sub>",
                desc: "Tailing Factor"
            },
            "Tl": {
                abbv: "T<sub>L</sub>",
                desc: "Track Length in cm"
            },
            "PW5": {
                abbv: "PW<sub>5</sub>",
                desc: "Peak Width at 5% Height"
            },
            "PW10": {
                abbv: "PW<sub>10</sub>",
                desc: "Peak Width at 10% Height"
            },
            "PW50": {
                abbv: "PW<sub>50</sub>",
                desc: "Peak Width at 50% Height"
            },
            "PW0": {
                abbv: "PW<sub>0</sub>",
                desc: "Peak Width at 0% Height"
            },
            "XPOS": {
                abbv: "X<sub>POS</sub>",
                desc: "X Position of Spot Center"
            },
            "YPOS": {
                abbv: "Y<sub>POS</sub>",
                desc: "Y Position of Spot Center"
            },
            "α": {
                abbv: "α",
                desc: "Separation Factor"
            },
            "EEP": {
                abbv: "E<sub>EP</sub>",
                desc: "Efficiency - European Pharmacopeia"
            },
            "EUSP": {
                abbv: "E<sub>USP</sub>",
                desc: "Efficiency - United States Pharmacopeia"
            },
            "NS": {
                abbv: "N<sub>S</sub>",
                desc: "Normalized Surface"
            },
            "Ret": {
                abbv: "Ret",
                desc: "Retention"
            },
            "RˉF": {
                abbv: "R&#772;<sub>F</sub>",
                desc: "Average Retention Factor"
            },
            "REP": {
                abbv: "Rs<sub>EP</sub>",
                desc: "Resolution - European Pharmacopeia"
            },
            "RUSP": {
                abbv: "Rs<sub>USP</sub>",
                desc: "Resolution - United States Pharmacopeia"
            },
            "RS": {
                abbv: "Rs",
                desc: "Resolution - Universal Formula"
            },
            "Sel": {
                abbv: "Sel",
                desc: "Selectivity"
            }
        };        

        function toggle_CanvasSpace(){
            const canvasSpace = document.getElementById("canvas_space");
            canvasSpace.style.display = (canvasSpace.style.display === "none") ? "block" : "none";
        }

        function getSpotReference(){

            if (!selectedTrack || !selectedTrack.target) return;
            
            const paramsData = selectedTrack.target.dataset.params;
            if (!paramsData) return;
            
            try {
                const paramsObject = JSON.parse(paramsData);
                if (typeof paramsObject !== "object" || paramsObject === null) return;
                const param = paramsObject.surface;
                if (typeof param !== "object" || !param.hasOwnProperty("description") || !param.hasOwnProperty("value")) return;
                referenceSurface = param.value;
                saveToIndexedDB(JSON.stringify(referenceSurface), 'referenceSurface');
                setSurfaceReference(referenceSurface);
            }
            catch{
                console.error(err);
            }            
        }

        function setSurfaceReference(referenceValue) {
            let surfaceRefDiv = document.getElementById("surfaceRef");
            if (!surfaceRefDiv) {
                console.error("Element with id 'surfaceRef' not found.");
                return;
            }

            let mathML = `
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                    <mrow>
                        <mi>I</mi>
                        <mo>=</mo>
                        <mn>${referenceValue.toFixed(3)}</mn>
                    </mrow>
                </math>
            `;

            surfaceRefDiv.innerHTML = mathML;
        }

        // Funkcja do pobrania i parsowania danych JSON z IndexedDB
        function loadJsonDataFromIndexedDB(dbName, storeName, key) {
            return new Promise((resolve, reject) => {
                // Pobierz dane JSON z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((jsonData) => {
                    try {
                        // Parsowanie danych JSON
                        const parsedData = JSON.parse(jsonData);
                        //console.log(parsedData);
                        // Przypisanie danych do odpowiednich zmiennych globalnych
                        if (key === "baselines") {
                            baselines = parsedData;
                        } else if (key === "draggable_coordinates") {
                            draggable_coordinates = parsedData;
                        }
                        else if (key === "concentrationData") {
                            if (parsedData === null || parsedData === undefined) {
                                concentrationData = [];
                            }
                            else{
                                concentrationData = parsedData;
                            }
                        } 
                        else if (key === "concentrationCurve") {
                            if (parsedData === null || parsedData === undefined) {
                                concentrationCurve = { slope : 0, intercept: 0, rSquared: 0 };
                            }
                            else{
                                concentrationCurve = parsedData;
                            }
                        }                     
                        else if (key === "referenceSurface") {
                            if (parsedData === null || parsedData === undefined) {
                                referenceSurface = 1;
                            }
                            else{
                                referenceSurface = parsedData;
                            }
                        } 
                        else if (key === "normalizationParams") {
                            if (parsedData === null || parsedData === undefined) {
                                normalizationParams  = {};
                            }
                            else{
                                normalizationParams  = parsedData;
                            }
                        }                         
                        // Zwróć Promise po udanym załadowaniu
                        resolve();
                    } catch (error) {
                        reject(`Error parsing JSON data: ${error}`);
                    }
                }).catch((error) => {
                    console.error('Error loading data from IndexedDB:', error);
                    reject(error);
                });
            });
        }

        // Funkcja do wstawienia obrazu na odpowiedni canvas
        function loadImageToCanvas(dbName, storeName, key, canvasId) {
            return new Promise((resolve, reject) => {
                // Pobierz URL obrazu z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((imageUrl) => {
                    // Znajdź odpowiedni element canvas
                    const canvas = document.getElementById(canvasId);
                    if (canvas && imageUrl) {
                        const img = new Image();
                        img.onload = () => {
                            // Ustaw rozmiar canvasu na rozmiar obrazu
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // Rysuj obraz na canvas
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(img, 0, 0);  // Wstaw obraz na canvas

                            // Zwróć Promise po załadowaniu obrazu
                            resolve();
                        };
                        img.src = imageUrl;  // Ustaw źródło obrazu
                    } else {
                        reject('Error loading image.');
                    }
                }).catch((error) => {
                    console.error('Error loading image:', error);
                    reject(error);
                });
            });
        }

        // Funkcja, która ma być uruchomiona po załadowaniu obu obrazów
        function onAllDataLoaded() {
            normalizeCanvasData();
            extractTrackData(draggable_coordinates, baselines);
            countParams();
            displayConcentrationData();
            showConcentrationCurve();
            setSurfaceReference(referenceSurface);
        }

        function autostart() {
            const dbName = "TLC";
            const storeName = "data";

            // Ładowanie obu obrazów jednocześnie
            Promise.all([
                loadImageToCanvas(dbName, storeName, "spots", "spots"),
                loadImageToCanvas(dbName, storeName, "background", "background"),
                loadJsonDataFromIndexedDB(dbName, storeName, "baselines"),
                loadJsonDataFromIndexedDB(dbName, storeName, "draggable_coordinates"),
                loadJsonDataFromIndexedDB(dbName, storeName, "concentrationData"),
                loadJsonDataFromIndexedDB(dbName, storeName, "concentrationCurve"),
                loadJsonDataFromIndexedDB(dbName, storeName, "referenceSurface"),
                loadJsonDataFromIndexedDB(dbName, storeName, "normalizationParams")
            ]).then(() => {
                // Po załadowaniu obu obrazów uruchom funkcję
                onAllDataLoaded();
            }).catch((error) => {
                console.error("An error occurred while loading images:", error);
            });            
        }

        // Ładowanie obrazów na kanwasy po załadowaniu strony
        window.onload = () => {
            autostart();
        };

        function normalizeCanvasData() {
            // Pobierz referencje do canvasów
            const spotsCanvas = document.getElementById("spots");
            const backgroundCanvas = document.getElementById("background");

            // Sprawdź, czy oba canvas mają takie same wymiary
            if (spotsCanvas.width !== backgroundCanvas.width || spotsCanvas.height !== backgroundCanvas.height) {
                alert("Canvases have different dimensions! Make sure both canvases have the same dimensions.");
                return;
            }

            // Pobierz ImageData z obu canvasów
            const spotsContext = spotsCanvas.getContext("2d");
            const backgroundContext = backgroundCanvas.getContext("2d");

            const spotsImageData = spotsContext.getImageData(0, 0, spotsCanvas.width, spotsCanvas.height);
            const backgroundImageData = backgroundContext.getImageData(0, 0, backgroundCanvas.width, backgroundCanvas.height);

            // Przygotuj nowy canvas na wynik
            const normalizedCanvas = document.getElementById("normalised");
            normalizedCanvas.width = spotsCanvas.width;
            normalizedCanvas.height = spotsCanvas.height;
            const normalizedContext = normalizedCanvas.getContext("2d");
            const normalizedImageData = normalizedContext.createImageData(spotsCanvas.width, spotsCanvas.height);

            const treshold = parseInt(document.getElementById('treshold').value);
            // Przetwórz piksel po pikselu
            for (let i = 0; i < spotsImageData.data.length; i += 4) {
                const rSpots = spotsImageData.data[i];     // Czerwony kanał z spots
                const rBackground = backgroundImageData.data[i]; // Czerwony kanał z background

                // Podziel kanał czerwony spots przez kanał czerwony background i przemnóż przez 255
                let rNormalized;
                if (rBackground === 0) {
                    rNormalized = 255; // Unikaj dzielenia przez zero
                } else {
                    rNormalized = (rSpots / rBackground) * 255;
                }

                // Ustaw ograniczenie na wartość z input
                rNormalized = rNormalized > treshold ? 255 : rNormalized;

                // Ustaw wynik dla wszystkich kanałów (RGB)
                normalizedImageData.data[i] = rNormalized;        // R
                normalizedImageData.data[i + 1] = rNormalized;    // G
                normalizedImageData.data[i + 2] = rNormalized;    // B
                normalizedImageData.data[i + 3] = 255;            // A (pełna przezroczystość)
            }

            // Wstaw ImageData do canvasu "normalised"
            normalizedContext.putImageData(normalizedImageData, 0, 0);
        }

        // Function to blur an array using a kernel size
        function blurArray(inputArray, kernelSize) {
            const outputArray = new Array(inputArray.length).fill(0);
            const halfKernel = Math.floor(kernelSize / 2);

            for (let i = 0; i < inputArray.length; i++) {
                let sum = 0;
                let count = 0;

                for (let k = -halfKernel; k <= halfKernel; k++) {
                    const idx = i + k;
                    if (idx >= 0 && idx < inputArray.length) {
                        sum += inputArray[idx];
                        count++;
                    }
                }
                if (inputArray[i] === 0) {
                outputArray[i] = 0;
                }
                else{
                outputArray[i] = sum / count;
                }
            }
            return outputArray;
        }

        function analyzeArrayWithKernel(array, kernelSize, height) {
            const mountains = [];
            let status = "constant"; // Possible values: "constant", "ascending", "descending"
            let mountainStart = null;
            let mountainEnd = null;

            for (let i = 0; i < array.length; i++) {
                // Get neighbors to the right based on kernel size
                const neighbors = [];
                for (let k = 1; k <= kernelSize; k++) {
                    if (i + k < array.length) {
                        neighbors.push(array[i + k]);
                    }
                }

                // Calculate the average of neighbors
                const average = neighbors.length > 0 
                    ? neighbors.reduce((sum, val) => sum + val, 0) / neighbors.length
                    : 0;

                // Determine the new status based on comparison with average
                let newStatus;
                if (array[i] > average) {
                    newStatus = "descending";
                } else if (array[i] < average) {
                    newStatus = "ascending";
                } else {
                    newStatus = "constant";
                }

                // Handle status change logic
                if (newStatus !== status) {
                    if ((status === "constant" || status === "descending") && newStatus === "ascending" ) {
                    if (mountainStart !== null) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = i;
                        mountainEnd = null;                
                    }
                    else{
                        mountainStart = mountainStart === null ? i : mountainStart;
                    }
                        
                    } 
                    else if (status === "descending" && mountainStart !== null && (newStatus === "constant" )) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = null;
                        mountainEnd = null;
                    }          

                    // Update status
                    //console.log(status, newStatus);
                    status = newStatus;
                    
                }
            }
            // Find the global minimum and maximum values in arr
            const globalMin = Math.min(...array);
            const globalMax = Math.max(...array);
            const globalDistance = globalMax - globalMin;
            // Validate and extract real mountains
            const realMountains = mountains.filter(({ start, end }) => {
            const fragment = array.slice(start, end + 1); // Get the fragment of arr
            const fragmentMin = Math.min(...fragment);
            const fragmentMax = Math.max(...fragment);
            const fragmentDistance = fragmentMax - fragmentMin;

            // Compare fragment distance to x% of global distance
            return fragmentDistance >= (height / 100) * globalDistance;
            });
            return realMountains;
        }

        function extractTrackData(draggable_coordinates, baselines) {
            // Uzyskanie dostępu do głównego canvas
            const normCanvas = document.getElementById('normalised');
            const normCtx = normCanvas.getContext('2d');
            const kernelSize = parseInt(document.getElementById('kernelSize').value);
            const track_space = document.getElementById('track_space');
            track_space.innerHTML = '';
            draggable_coordinates.forEach(coordinate => {
                // Wydobywanie danych z ImageData dla podanych współrzędnych
                const imageData = normCtx.getImageData(baselines.x, coordinate.y, baselines.width, coordinate.height);
                // Tworzenie nowego canvas i kontekstu
                const newCanvas = document.createElement('canvas');
                const newCtx = newCanvas.getContext('2d');
                
                // spot position params preparation
                const Ycentral = (coordinate.y + coordinate.height / 2) / normCanvas.height;
                // Ustawianie rozmiaru nowego canvas
                newCanvas.width = baselines.width;
                newCanvas.height = coordinate.height;

                // Wstawianie ImageData do nowego canvas
                newCtx.putImageData(imageData, 0, 0);

                // Tworzenie nowego div'a z odpowiednim id
                const newDiv = document.createElement('div');
                newDiv.style.position = 'relative';
                newDiv.classList.add("track");
                newDiv.id = coordinate.name;  // Ustawianie id div'a na podstawie 'name' w draggable_coordinates
                newDiv.dataset.Ypos = JSON.stringify(Ycentral);
                newDiv.dataset.Xstart = JSON.stringify(baselines.x);
                newDiv.dataset.Xwidth = JSON.stringify(normCanvas.width);

                // Tworzenie tablicy 1D z sumami kanału czerwonego dla każdej kolumny
                const RedSums = [];
                for (let x = 0; x < imageData.width; x++) {
                    let sumRed = 0;
                    for (let y = 0; y < imageData.height; y++) {
                        const index = (y * imageData.width + x) * 4;
                        sumRed += 255 - imageData.data[index]; // Kanał czerwony to pierwszy element w tablicy (index * 4)
                    }

                    RedSums.push(sumRed); // Zapisanie sumy kanału czerwonego dla każdej kolumny
                }
                
                const blurredRedSums = blurArray(RedSums, kernelSize);
                const mountains = analyzeArrayWithKernel(blurredRedSums, 1, 1);
                //console.log(mountains);
                // Normalizacja RedSums (zakładając, że minimalna wartość to 0, a maksymalna to 250)
                const min = Math.min(...RedSums);
                const max = Math.max(...RedSums);
                const Bmin = Math.min(...blurredRedSums);
                const Bmax = Math.max(...blurredRedSums);
                const normalizedRedSums = RedSums.map(value => (value - min) / (max - min) * 250);
                const normalizedblurredRedSums = blurredRedSums.map(value => (value - Bmin) / (Bmax - Bmin) * 250);
                
                // Dodanie atrybutu data-red-sums do div'a z 1D tablicą RedSums
                newDiv.dataset.RedSums = JSON.stringify(RedSums);  // Użycie data-* atrybutu
                //newDiv.dataset.blurredSums = JSON.stringify(blurredRedSums); 
                // Tworzenie głównego canvas
                const mainCanvas = document.createElement('canvas');
                mainCanvas.classList.add('chart');
                mainCanvas.width = newCanvas.width;
                mainCanvas.height = 250;
                const ctx = mainCanvas.getContext('2d');

                // Rysowanie poziomych linii siatki i podpisów
                ctx.font = '12px Arial';
                ctx.fillStyle = 'gray';
                ctx.textAlign = 'right';
                for (let i = 1; i <= 9; i++) {
                const percent = 100 - i * 10; // 90%, 80%, ... 10%
                const y = (i * mainCanvas.height) / 10; // pozycja w % wysokości

                // linia
                ctx.beginPath();
                ctx.strokeStyle = 'lightgray';
                ctx.lineWidth = 1;
                ctx.moveTo(0, y);
                ctx.lineTo(mainCanvas.width, y);
                ctx.stroke();

                // podpis (np. 90%, 80% ...)
                ctx.fillText(`${percent}%`, mainCanvas.width - 5, y - 2);
            }

                // Rysowanie wykresu jako linia
                const showBlurr = document.getElementById("showBlurr");
                let chartData;
                if (showBlurr.checked) { // use blurred data to visualize
                    chartData = normalizedblurredRedSums;
                } else { // use unblurred (raw data)
                    chartData = normalizedRedSums;
                }

                ctx.beginPath();
                ctx.strokeStyle = 'steelblue';
                ctx.lineWidth = 2;
                chartData.forEach((value, index) => {
                    const x = (index / (chartData.length - 1)) * mainCanvas.width;
                    const y = 250 - value;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                const header = document.createElement('h2');
                header.textContent = coordinate.name;
                newDiv.appendChild(header);
                // Dodanie canvas z wykresem do div'a
                newDiv.appendChild(mainCanvas);

                // Dodanie br pomiędzy canvasami
                const br = document.createElement('br');
                newDiv.appendChild(br);

                // Dodanie canvas do div'a
                newDiv.appendChild(newCanvas);

                // Ustawianie marginesu dla new div'a -- nie teraz, bo trzeba sporo przerabiać
                //newDiv.style.paddingLeft = "1vw";

                // Dodanie div'a do dokumentu (np. do body)
                track_space.appendChild(newDiv);

                // Pobranie pozycji newDiv
                const newDivRect = newDiv.getBoundingClientRect();
                const mainCanvasRect = mainCanvas.getBoundingClientRect();
                const newCanvasRect = newCanvas.getBoundingClientRect();

                // Obliczenie wysokości od góry mainCanvas do dołu newCanvas względem newDiv
                const totalHeight = newCanvasRect.bottom - mainCanvasRect.top;

                // Tworzenie divów dla każdego obiektu w mountains
                mountains.forEach(({ start, end }) => {
                    const mountainDiv = document.createElement('div');
                    
                    mountainDiv.style.position = 'absolute';
                    mountainDiv.style.left = `${start - newDivRect.left}px`;  // Względem newDiv
                    mountainDiv.style.width = `${end - start}px`;
                    mountainDiv.style.top = `${mainCanvasRect.top - newDivRect.top}px`; // Względem newDiv
                    mountainDiv.style.height = `${totalHeight}px`;
                    mountainDiv.style.backgroundColor = 'rgba(0, 0, 255, 0.3)'; // Przezroczysty kolor dla widoczności

                    newDiv.appendChild(mountainDiv);
                    createDraggableElement(newDiv, mountainDiv);
                });

            });
        }

        // zaokrąglanie do d miejsc po przecinku
        function reduceDecimals(value, decimals) {
            if (typeof value === 'number' && !isNaN(value)) {
                if (decimals === -1) {
                    // nie zaokrąglamy, zwracamy oryginalną liczbę
                    return value;
                }
                // jeśli decimals >= 0 → zaokrąglamy
                if (typeof decimals === 'number' && decimals >= 0) {
                    return Number(value.toFixed(decimals));
                }
            }
            return value; // jeśli nie liczba, zwracamy oryginał
        }

        // kopiowanie zawartości wyników do raportu do schowka
        function copyData() {
            // załąduj ustawienia z local storage
            let wybrane;
            let wybrane_length;
            let decimals;
            try {
                wybrane = JSON.parse(localStorage.getItem('wybraneParametryTLCv3'));
                wybrane_length = Object.values(wybrane).length;
                decimals = JSON.parse(localStorage.getItem('decimalsTLCv3'));
            } catch (e) {
                wybrane = null;
                wybrane_length = 0
                decimals = -1;
            }

            // otwórz nowe okno
            const popup = window.open('', '', 'width=800,height=600,scrollbars=yes,resizable=yes');
            popup.document.write('<html><head><title>Computed Data</title></head><body>');
            
            document.querySelectorAll('.track').forEach(track => {
                // HR + nagłówek z tekstem tracka
                popup.document.write('<hr><h2>' + track.textContent + '</h2>');

                // pobierz draggables
                const draggables = Array.from(track.querySelectorAll('.draggable'));

                // zmapuj Xcentral
                const withX = draggables.map(el => {
                    let x = Infinity;
                    try {
                        const params = JSON.parse(el.dataset.params || '{}');
                        const n = Number(params.Xcentral);
                        x = Number.isFinite(n) ? n : Infinity;
                    } catch (e) {}
                    return { el, x };
                });

                // sortuj po Xcentral
                withX.sort((a, b) => a.x - b.x);

                // dla każdego draggable
                let P_nr = 1;
                withX.forEach(({ el }) => {
                    try {
                        const paramsObject = JSON.parse(el.dataset.params || '{}');
                        if (typeof paramsObject !== "object" || paramsObject === null) return;
                        // zbuduj tabelę dla tego draggable
                        let tableHTML = '<table border="1" style="display:inline-block; margin:5px; border-collapse:collapse;">';
                        tableHTML += `<tr><th><strong>Parameter</strong></th><th><strong>Peak ${P_nr}</strong></th></tr>`;
                        P_nr++;

                            const colorOrder = ['white', 'Thistle', 'lavender', 'bisque'];

                            Object.entries(paramsObject)
                            .sort(([keyA, a], [keyB, b]) => {
                                const colorA = a.color ?? "";
                                const colorB = b.color ?? "";
                                const colorRankA = colorOrder.indexOf(colorA);
                                const colorRankB = colorOrder.indexOf(colorB);
                                if (colorRankA !== colorRankB) return colorRankA - colorRankB;

                                const descA = a.description ?? "";
                                const descB = b.description ?? "";
                                return descA.localeCompare(descB);
                            })
                            .forEach(([key, param]) => {
                                // param musi mieć description i value
                                if (typeof param !== "object" || 
                                    !param.hasOwnProperty("description") || 
                                    !param.hasOwnProperty("value")) return;

                                // dodaj wiersz do tabeli
                                if (!wybrane || param.description in wybrane || wybrane_length === 0 ) { // jeśli wybrano takie parametry do wyliczenia
                                    tableHTML += `<tr><td>${proposeAlternativeName(param.description)}</td><td>${reduceDecimals(param.value, decimals)}</td></tr>`;
                                }
                            });

                        tableHTML += '</table><br>';

                        popup.document.write(tableHTML);

                    } catch (err) {
                        console.log(err);
                    }
                });
            });

            popup.document.write('</body></html>');
            popup.document.close();
        }


        // kopiuj obraz do raportu do schowka
        function copyImage(){
            // track_space to element <div> przeznaczony na canvases z wykresami itd.
            html2canvas(track_space).then(canvas => {
                canvas.toBlob(blob => {
                    // Skopiuj do schowka jako obraz
                    navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]).then(() => {
                        console.log('Screenshot copied to clipboard!');
                    }).catch(err => {
                        console.error('Could not copy to clipboard', err);
                    });
                });
            });
        }

        function addDraggableElement() {
            const element = selectedTrack.target;
            const container = element.parentElement;
            //const RectContainer = container.getBoundingClientRect();
            const mountainDiv = document.createElement('div');
                    
            mountainDiv.style.position = 'absolute';
            mountainDiv.style.left = element.style.left;
            mountainDiv.style.width = element.style.width;
            mountainDiv.style.top = element.style.top;
            mountainDiv.style.height = element.style.height;
            mountainDiv.style.backgroundColor = 'rgba(0, 0, 255, 0.3)'; // Przezroczysty kolor dla widoczności
            container.appendChild(mountainDiv);
            createDraggableElement(container, mountainDiv);
        }

        // Moveable setup
        function createDraggableElement(container, element) {
            if (!container) return;
            const containerHeight = container.getBoundingClientRect().height;
            element.classList.add("draggable");
            
            const movable = new Moveable(container, {
                target: element,
                draggable: true,
                throttleDrag: 1,
                edgeDraggable: false,
                startDragRotate: 0,
                throttleDragRotate: 0,
                resizable: true,
                keepRatio: false,
                throttleResize: 1,
                renderDirections:  ["w", "e"],
                bounds: { left: 0, right: 0 }        
            });
            movable.on("drag", e => {
                e.target.style.left = `${e.left}px`;
            });
            movable.on("resize", e => {
                e.target.style.width = `${e.width}px`;
                e.target.style.transform = e.drag.transform;
            });
            movable.on("click", e => {
                resetDraggablesColor();
                selectedTrack = {target: e.target, moveable: e.moveable};
                e.target.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                updateParameterBox();
            });
        }

        function resetDraggablesColor() {
            document.querySelectorAll(".draggable").forEach(el => {
                el.style.backgroundColor = 'rgba(0, 0, 255, 0.3)';
            });
        }

        function unselectElement(){
            selectedTrack = null;
            resetDraggablesColor();
        }

        function removeSelectedElement() {
            if (selectedTrack) {
                selectedTrack.moveable.controlBox.remove();
                selectedTrack.moveable.destroy();
                selectedTrack.target.remove();
                selectedTrack = null;
            }
        }

        // Implementacja interpolacji splajnów kubicznych w czystym JS
        class CubicSpline {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.n = x.length - 1;
                this.h = [];
                this.b = [];
                this.c = new Array(this.n + 1).fill(0);
                this.d = new Array(this.n).fill(0);

                for (let i = 0; i < this.n; i++) {
                    this.h[i] = x[i + 1] - x[i];
                }

                let alpha = new Array(this.n).fill(0);
                for (let i = 1; i < this.n; i++) {
                    alpha[i] = (3 / this.h[i]) * (y[i + 1] - y[i]) - (3 / this.h[i - 1]) * (y[i] - y[i - 1]);
                }

                let l = new Array(this.n + 1).fill(1);
                let mu = new Array(this.n).fill(0);
                let z = new Array(this.n + 1).fill(0);

                for (let i = 1; i < this.n; i++) {
                    l[i] = 2 * (x[i + 1] - x[i - 1]) - this.h[i - 1] * mu[i - 1];
                    mu[i] = this.h[i] / l[i];
                    z[i] = (alpha[i] - this.h[i - 1] * z[i - 1]) / l[i];
                }

                for (let j = this.n - 1; j >= 0; j--) {
                    this.c[j] = z[j] - mu[j] * this.c[j + 1];
                    this.b[j] = (y[j + 1] - y[j]) / this.h[j] - this.h[j] * (this.c[j + 1] + 2 * this.c[j]) / 3;
                    this.d[j] = (this.c[j + 1] - this.c[j]) / (3 * this.h[j]);
                }
            }

            at(xi) {
                if (xi < this.x[0]) {
                    return this.y[0]; // Jeśli xi jest poza zakresem, zwróć wartość na początku
                }
                if (xi > this.x[this.n]) {
                    return this.y[this.n]; // Jeśli xi jest poza zakresem, zwróć wartość na końcu
                }

                let i = this.x.findIndex((val, index) => index < this.n && this.x[index + 1] > xi);
                if (i === -1) i = this.n - 1;

                let dx = xi - this.x[i];
                return this.y[i] + this.b[i] * dx + this.c[i] * dx ** 2 + this.d[i] * dx ** 3;
            }
        }

        function cubicSplineInterpolationAndExtrapolate(data, start, end) {
            const midpoint = findMidpointIndex(data, start, end);

            const xLeft = Array.from({ length: midpoint - start + 1 }, (_, i) => start + i);
            const yLeft = xLeft.map(i => data[i]);
            const splineLeft = new CubicSpline(xLeft, yLeft);

            const xRight = Array.from({ length: end - midpoint + 1 }, (_, i) => midpoint + i);
            const yRight = xRight.map(i => data[i]);
            const splineRight = new CubicSpline(xRight, yRight);

            function predictLeft(xi) {
                return splineLeft.at(xi);
            }

            function predictRight(xi) {
                return splineRight.at(xi);
            }

            let extendedData = [...data];

            let nextIndex = end + 1;
            while (predictRight(nextIndex) > 0) {
                extendedData[nextIndex] = predictRight(nextIndex);
                nextIndex++;
            }

            let prevIndex = start - 1;
            while (prevIndex >= 0 && predictLeft(prevIndex) > 0) {
                extendedData[prevIndex] = predictLeft(prevIndex);
                prevIndex--;
            }

            return { data: extendedData, newStart: prevIndex + 1, newEnd: nextIndex - 1 };
        }



        function findMidpointIndex(data, start, end) {
            const maxVal = Math.max(...data.slice(start, end + 1));
            const maxIndices = [];

            for (let i = start; i <= end; i++) {
                if (data[i] === maxVal) {
                    maxIndices.push(i);
                }
            }

            return Math.round(maxIndices.reduce((sum, i) => sum + i, 0) / maxIndices.length);
        }        

        function extendPeaks(){
            document.querySelectorAll(".track").forEach(track => {
                let redSums = JSON.parse(track.dataset.RedSums);
                let canvas = track.querySelector(".chart");
                let ctx = canvas.getContext("2d");

                track.querySelectorAll(".draggable").forEach(draggable => {
                    const Rect = draggable.getBoundingClientRect();
                    let start = parseInt(Rect.left) || 0;
                    let end = parseInt(Rect.width) + parseInt(Rect.left) || redSums.length;
                    
                    let result = cubicSplineInterpolationAndExtrapolate(redSums, start, end);
                    result.data = result.data.slice(result.newStart, result.newEnd);
                    let normalizedData = result.data.map(v => (v / Math.max(...redSums)) * 250);
                    draggable.dataset.result = JSON.stringify(result);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = "red";
                    ctx.lineWidth = 2;
                    
                    normalizedData.forEach((val, i) => {
                        let x = i + result.newStart;
                        let y = canvas.height - val;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                }); 
            });        
        }
    
        // Funkcja: znajdź najbliższego sąsiada po położeniu na osi x (zwraca nazwę substancji lub null)
        function findNearestSubstance(xValue, substances, substanceTreshold) {
            if (!Array.isArray(substances) || substances.length === 0) return null;

            // jeśli tylko jeden element
            if (substances.length === 1) {
                const s = substances[0];
                //console.log(s.name, s.x, xValue, Math.abs(xValue - s.x), Math.abs(xValue - s.x) <= substanceTreshold);
                if (typeof s.x === "number" && Math.abs(xValue - s.x) <= substanceTreshold) {
                    return s.name;
                } else {
                    return null;
                }
            }

            // dla wielu elementów
            let nearest = null;
            let minDiff = Infinity;

            for (let i = 0; i < substances.length; i++) {
                const s = substances[i];
                if (typeof s.x !== "number") continue; // ignoruj niepoprawne wpisy

                const diff = Math.abs(xValue - s.x);
                if (diff < minDiff) {
                    nearest = s;
                    minDiff = diff;
                }
            }

            if (!nearest) return null; // brak poprawnych punktów

            return minDiff <= substanceTreshold ? nearest.name : null;
        }

        function countParams() {
            document.querySelectorAll(".track").forEach(track => {
                let redSums = JSON.parse(track.dataset.RedSums);
                const maxHeight = Math.max(...redSums); // Maksymalna wartość w redSums
                const Ypos = JSON.parse(track.dataset.Ypos);
                const Xstart = JSON.parse(track.dataset.Xstart);
                const Xwidth = JSON.parse(track.dataset.Xwidth);

                track.querySelectorAll(".draggable").forEach(draggable => {
                    const rect = draggable.getBoundingClientRect();
                    let start = parseInt(rect.left) || 0;
                    let end = parseInt(rect.width) + parseInt(rect.left) || redSums.length;
                    const data = redSums.slice(start, end);
                    const midpointIndex = findMidpointIndex(redSums, start, end);
                    const Xpos = (Xstart + midpointIndex ) / Xwidth;
                    const peakMaxHeight = Math.max(...data);
                    const peakMaxHeightPercent = (peakMaxHeight / maxHeight) * 100;

                    const getWidthAtHeight = (heightFraction) => {
                        let threshold = peakMaxHeight * heightFraction;
                        let left = start;
                        let right = end - 1;
                        
                        while (left < end && redSums[left] < threshold) left++;
                        while (right > start && redSums[right] < threshold) right--;
                        
                        return right - left;
                    };

                    const Wbas = getWidthAtHeight(0);
                    const W50 = getWidthAtHeight(0.5);
                    const W10 = getWidthAtHeight(0.1);
                    const W05 = getWidthAtHeight(0.05);
                    const surface = data.reduce((sum, val) => sum + val, 0);

                    const getDistanceAtHeight = (heightFraction) => {
                        let threshold = peakMaxHeight * heightFraction;
                        let left = start;
                        let right = end - 1;
                        
                        while (left < end && redSums[left] < threshold) left++;
                        while (right > start && redSums[right] < threshold) right--;
                        
                        return {
                            A: midpointIndex - left,
                            B: right - midpointIndex
                        };
                    };

                    const A05 = getDistanceAtHeight(0.05).A;
                    const A10 = getDistanceAtHeight(0.10).A;
                    const B05 = getDistanceAtHeight(0.05).B;
                    const B10 = getDistanceAtHeight(0.10).B;
                    const asymmetryFactor = B10 / A10;
                    const tailingFactor = W05 / (2 * A05);

                    const trackName = track.textContent.replace(/^Track:\s*/, '');

                    const params = JSON.stringify({
                        track: { value: trackName, description: "Track Name (TN)", color: 'white'},
                        midpointIndex: { value: midpointIndex, description: "Midpoint Index (MI)", color: 'bisque'},
                        maxHeight: { value: maxHeight, description: "Maximal Height on Track (HTrack)", color: 'bisque' },
                        peakMaxHeight: { value: peakMaxHeight, description: "Peak Height (H)", color: 'Thistle' },
                        peakMaxHeightPercent: { value: peakMaxHeightPercent, description: "Peak Height to Track Height Ratio (H%)", color: 'Thistle' },
                        Wbas: { value: Wbas, description: "Peak Width at 0% Height (PW0)", color: 'bisque' },
                        W50: { value: W50, description: "Peak Width at 50% Height (PW50)", color: 'bisque' },
                        W10: { value: W10, description: "Peak Width at 10% Height (PW10)", color: 'bisque' },
                        W05: { value: W05, description: "Peak Width at 5% Height (PW5)", color: 'bisque' },
                        surface: { value: surface, description: "Spot Area (S)", color: 'white' },
                        A05: { value: A05, description: "Startpoint to Midpoint Distance at 5% of Height (SM5)", color: 'bisque' },
                        A10: { value: A10, description: "Startpoint to Midpoint Distance at 10% of Height (SM10)", color: 'bisque' },
                        B05: { value: B05, description: "Midpoint to Endpoint Distance at 5% of Height (ME5)", color: 'bisque' },
                        B10: { value: B10, description: "Midpoint to Endpoint Distance at 10% of Height (ME10)", color: 'bisque' },
                        asymmetryFactor: { value: asymmetryFactor, description: "Asymmetry Factor​​ (AS)", color: 'Thistle' },
                        tailingFactor: { value: tailingFactor, description: "Tailing Factor (TF)", color: 'Thistle' },
                        Ycentral: {value: Ypos, description: "Y Position of Spot Center (YPOS)", color: 'bisque'},
                        Xcentral: {value: Xpos, description: "X Position of Spot Center (XPOS)", color: 'bisque'},
                    });

                    draggable.dataset.params = params;
                });
            });
            // count secondary params
            countSecondaryParams();
        }

        function countSecondaryParams() {
            // załaduj ustawienia z localStorage
            let substances;
            let substanceTreshold;
            try {
                substances = JSON.parse(localStorage.getItem('substancesTLCv3'));
                if (!Array.isArray(substances)) {
                    substances = []; // jeśli nie tablica, to pusta
                }
                substanceTreshold = JSON.parse(localStorage.getItem('tresholdTLCv3'));
                if (typeof substanceTreshold === "number" && substanceTreshold < 0 || substanceTreshold > 1) {
                    substanceTreshold = 0.05; // domyslna wartość
                }
            } catch (e) {
                substances = [];
                substanceTreshold = 0.05; // domyslna wartość
            }

            document.querySelectorAll(".track").forEach(track => {
                let redSums = JSON.parse(track.dataset.RedSums);

                track.querySelectorAll(".draggable").forEach(draggable => {

                    let params = JSON.parse(draggable.dataset.params);
                    params.plate_width = { 
                        value: baselines.plate_width, // globalna zmienna
                        description: "Plate Width in cm (PlW)", 
                        color: 'bisque'
                    };

                    const spotsElement = document.getElementById('spots');
                    if (spotsElement) {
                        params.track_width = { 
                            value: (redSums.length / spotsElement.width) * params.plate_width.value, 
                            description: "Track Length in cm (Tl)",
                            color: 'bisque'
                        };
                    } else {
                        console.error("Element #spots nie istnieje");
                    }

                    params.RF = { 
                        value: params.midpointIndex.value / redSums.length, 
                        description: "Retardation Factor (RF)",
                        color: 'Thistle'
                    };

                    // #*#*#*
                    const predictedSubstance = findNearestSubstance(params.RF.value, substances, substanceTreshold);                    
                    params.name = {
                        value: (predictedSubstance !== null ? predictedSubstance : "unknown substance"),
                        description: "Peak Name (PN)",
                        color: 'white'
                    };

                    params.k = { 
                        value: (1 - params.RF.value) / params.RF.value, 
                        description: "Capacity Factor (k)",
                        color: 'Thistle' 
                    };

                    params.RM = { 
                        value: Math.log10(params.k.value), 
                        description: "Logarithmic Retardation Factor (RMLog10)",
                        color: 'Thistle'
                    };

                    params.HobsBAS = { 
                        value: (params.Wbas.value ** 2) / (16 * params.midpointIndex.value), 
                        description: "Height Equivalent to a Theoretical Plate - United States Pharmacopeia (HETPUSP)",
                        color: 'lavender'
                    };

                    params.Hobs05 = { 
                        value: (params.W50.value ** 2) / (5.54 * params.midpointIndex.value), 
                        description: "Height Equivalent to a Theoretical Plate - European Pharmacopeia (HETPEP)",
                        color: 'lavender'   
                    };

                    params.NobsBAS = { 
                        value: (16 * params.midpointIndex.value) / params.Wbas.value, 
                        description: "Number of Theoretical Plates - United States Pharmacopeia​ (NUSP)",
                        color: 'lavender'
                    };

                    params.Nobs05 = { 
                        value: (params.midpointIndex.value / params.W50.value) ** 2 * 5.54, 
                        description: "Number of Theoretical Plates - European Pharmacopeia​ (NEP)",
                        color: 'lavender'   
                    };

                    params.N_mBAS = { 
                        value: params.NobsBAS.value * (100 / params.track_width.value), 
                        description: "Number of Theoretical Plates per meter - United States Pharmacopeia (NUSP/m)",
                        color: 'lavender'
                    };

                    params.N_m05 = { 
                        value: params.Nobs05.value * (100 / params.track_width.value), 
                        description: "Number of Theoretical Plates per meter - European Pharmacopeia​ (NEP/m)",
                        color: 'lavender'   
                    };

                    draggable.dataset.params = JSON.stringify(params);
                });
            });
            countTertiaryParams();
        }

        function countTertiaryParams() {
            document.querySelectorAll(".track").forEach(track => {

                let draggableData = [];
                let maxSurface = 0; // Przechowuje największą wartość surface.value w danym track

                // 1. Iterujemy i zbieramy dane
                track.querySelectorAll(".draggable").forEach(draggable => {
                    const rect = draggable.getBoundingClientRect();
                    let start = parseInt(rect.left) || 0;
                    let end = parseInt(rect.width) + parseInt(rect.left) || redSums.length;
                    let center = (start + end) / 2;

                    let params = JSON.parse(draggable.dataset.params);
                    
                    // Sprawdzenie, czy surface.value istnieje
                    if (params.surface && params.surface.value) {
                        maxSurface = Math.max(maxSurface, params.surface.value);
                    }

                    draggableData.push({ draggable, params, center });
                });

                // 2. Sortowanie draggable według środka
                draggableData.sort((a, b) => a.center - b.center);

                // 3. Dodanie maxSurface do każdego draggable i zapisanie
                draggableData.forEach(({ draggable, params }, index) => {
                    params.maxSurface = {  
                        value: maxSurface,  
                        description: "Greatest Peak Surface for Track (STrack)", 
                        color: 'bisque' 
                    };

                    if ('grid' in normalizationParams) {
                        params.NormalizedSurface = {  
                            value: evaluateSpline3D(normalizationParams, params.Xcentral.value, params.Ycentral.value, params.surface.value), 
                            description: "Normalized Surface (NS)",
                            color: 'white'
                        };                         
                    }
                    
                    params.concentration = {  
                        value: predictConcentration(params.surface.value / referenceSurface),  
                        description: "Substance Concentration (C)",
                        color: 'white'
                    };                     
                    
                    if (maxSurface > 0) {
                        params.percentSurface = {  
                            value: (params.surface.value / maxSurface) * 100,  
                            description: "Peak Surface to Track Surface Ratio (S%)",
                            color: 'white'  
                        };
                    }
                    
                    if (index < draggableData.length - 1) { // dla każdego, ale nie ostatniego
                        let nextParams = draggableData[index + 1].params;
                        
                        if (params.k && nextParams.k) {
                            params.alpha = {  
                                value: Math.max(params.k.value, nextParams.k.value) / Math.min(params.k.value, nextParams.k.value),  
                                description: "Separation Factor (α)",
                                color: 'Thistle'  
                            };
                        }

                        if (params.RF && nextParams.RF && params.Wbas && nextParams.Wbas) {
                            params.RSz = {  
                                value: (nextParams.midpointIndex.value - params.midpointIndex.value ) / 0.5 / (nextParams.Wbas.value + params.Wbas.value),  
                                description: "Resolution - Universal Formula (RS)",
                                color: 'Thistle'   
                            };
                        }

                        if (params.k && nextParams.k) {
                            params.selectivity = {  
                                value: 0.25 * ( ( Math.max(nextParams.k.value, params.k.value) / Math.min(nextParams.k.value, params.k.value) ) - 1),  
                                description: "Selectivity (Sel)",
                                color: 'bisque'  
                            };
                        }

                        if (params.RF && nextParams.RF) {
                            params.RFavg = {  
                                value: (params.RF.value + nextParams.RF.value) / 2,  
                                description: "Average Retention Factor (RˉF)",
                                color: 'bisque'  
                            };
                            params.retention = {  
                                value: 1 - params.RFavg.value,  
                                description: "Retention (Ret)",
                                color: 'bisque'  
                            };
                        }

                        if (params.NobsBAS && nextParams.NobsBAS && params.RFavg) {
                            params.efficacyBAS = {  
                                value: Math.sqrt(params.RFavg.value * (params.NobsBAS.value + nextParams.NobsBAS.value) / 2),  
                                description: "Efficiency - United States Pharmacopeia (EUSP)",
                                color: 'bisque'
                            };
                        }
                        
                        if (params.Nobs05 && nextParams.Nobs05 && params.RFavg) {
                            params.efficacy50 = {  
                                value: Math.sqrt(params.RFavg.value * (params.Nobs05.value + nextParams.Nobs05.value) / 2),  
                                description: "Efficiency - European Pharmacopeia (EEP)",
                                color: 'bisque'    
                            };
                        }

                        if (params.selectivity && params.retention && params.efficacyBAS) {
                            params.RSssrBAS = {  
                                value: params.selectivity.value * params.retention.value * params.efficacyBAS.value,  
                                description: "Resolution - United States Pharmacopeia (RUSP)",
                                color: 'lavender'
                            };
                        }
                        
                        if (params.selectivity && params.retention && params.efficacy50) {
                            params.RSssr50 = {  
                                value: params.selectivity.value * params.retention.value * params.efficacy50.value,  
                                description: "Resolution - European Pharmacopeia (REP)",
                                color: 'lavender'  
                            };
                        }
                    }               
                    draggable.dataset.params = JSON.stringify(params); // Zapisanie zmian
                });
            });
        }

        // zmienia nazwę parametru w zależności od od wyboru użytkownika
        function proposeAlternativeName(old_name){
            // changing name to alterntive - START
            const storedValue = localStorage.getItem('naming_convention_V3'); // wczytujemy naming convention

            if (!storedValue || storedValue === "debug") {
                return old_name; // tu ustawiona nazwa stara
            } else {
                // Spróbuj znaleźć skrót w nawiasie, np. "PN" z "Peak Name (PN)"
                const match = old_name.match(/\(([^)]*)\)/);

                // Zmienna na skrót (np. "PN")
                const matchSingle = match ? match[1] : null; 

                // Sprawdzenie: Czy znaleziono skrót ORAZ czy skrót istnieje jako klucz w namingConvention
                const isValidKey = matchSingle && namingConvention.hasOwnProperty(matchSingle);

                if (isValidKey) {
                    // Jeśli klucz jest poprawny, przejdź do logiki z namingConvention
                    const changedElement = namingConvention[matchSingle];

                    if (storedValue === "descriptive") {
                        return changedElement.desc; // wstawia opis
                    } else if (storedValue === "abbreviated") {
                        return changedElement.abbv; // wstawia skrót (HTML)
                    } else if (storedValue === "desc_abbrev") {
                        // Użyj changedElement, które jest już zdefiniowane
                        return `${changedElement.desc} (${changedElement.abbv})`;
                    } else {
                        // W przypadku nieznanego storedValue, ustaw domyślnie
                        return old_name;
                    }

                } else {
                    // Zabezpieczenie: Jeśli matchSingle nieznalezione lub klucz nie istnieje
                    return old_name;
                }
            }     
            // changing name to alterntive - END            
        }

        // po kliknięciu w wykryty peak pokazuje pole z parametrami
        function updateParameterBox() {
            const parameterBox = document.getElementById('parameterBox');
            parameterBox.innerHTML = "";

            if (!selectedTrack || !selectedTrack.target) return;
            
            const paramsData = selectedTrack.target.dataset.params;
            if (!paramsData) return;
            
            try {
                const paramsObject = JSON.parse(paramsData);
                if (typeof paramsObject !== "object" || paramsObject === null) return;

                const list = document.createElement("ul");

                const colorOrder = ['white', 'Thistle', 'lavender', 'bisque'];

                Object.entries(paramsObject)
                .sort(([keyA, a], [keyB, b]) => {
                    const colorA = a.color ?? "";
                    const colorB = b.color ?? "";
                    const colorRankA = colorOrder.indexOf(colorA);
                    const colorRankB = colorOrder.indexOf(colorB);
                    if (colorRankA !== colorRankB) return colorRankA - colorRankB;

                    const descA = a.description ?? "";
                    const descB = b.description ?? "";
                    return descA.localeCompare(descB);
                })           
                .forEach(([key, param]) => {
                    if (typeof param !== "object" || !param.hasOwnProperty("description") || !param.hasOwnProperty("value")) return;

                    const listItem = document.createElement("li");
                    if (param.hasOwnProperty("color")) {
                        listItem.style.backgroundColor = param.color;
                    }
                    const label = document.createElement("label");
                    label.innerHTML = proposeAlternativeName(param.description);

                    const input = document.createElement("input");
                    if (param.description === "Peak Name (PN)" || param.description === "Track Name (TN)") { // dla nazwy - text
                        input.type = "text";
                        input.value = param.value;
                        input.dataset.paramKey = key;                     
                    }
                    else{ // dla pozostałych numer
                        input.type = "number";
                        input.value = param.value;
                        input.dataset.paramKey = key;
                    }
                    
                    input.addEventListener("input", () => {
                        saveParameterValues();
                    });
                    
                    listItem.appendChild(label);
                    listItem.appendChild(input);
                    list.appendChild(listItem);
                });

                parameterBox.appendChild(list);
            } catch (e) {
                console.error("Error parsing paramsData:", e);
            }
        }

        // zapisuje parametry z inputs
        function saveParameterValues() {
            if (!selectedTrack || !selectedTrack.target) return;

            const parameterBox = document.getElementById('parameterBox');
            const inputs = parameterBox.querySelectorAll("input");
            
            try {
                const paramsObject = JSON.parse(selectedTrack.target.dataset.params);
                
                inputs.forEach(input => {
                    const key = input.dataset.paramKey;
                    if (paramsObject[key]) { // is name = text
                        if (paramsObject[key].description === "Peak Name (PN)" || paramsObject[key].description === "Track Name (TN)") {
                            paramsObject[key].value = input.value;
                        }
                        else{ // not name = number float
                            paramsObject[key].value = parseFloat(input.value);
                        }
                    }
                });
                
                selectedTrack.target.dataset.params = JSON.stringify(paramsObject);
            } catch (e) {
                console.error("Error saving paramsData:", e);
            }
        }



        // Funkcja dodająca stężenie
        function addConcentration() {
            saveParameterValues();
            if (!selectedTrack || !selectedTrack.target) return;
            
            const paramsData = selectedTrack.target.dataset.params;
            const paramsObject = JSON.parse(paramsData);

            const surfaceValue = paramsObject.surface?.value;
            const concentrationValue = paramsObject.concentration?.value;
            const XPos = paramsObject.Xcentral?.value;
            const YPos = paramsObject.Ycentral?.value;            

            if (surfaceValue !== undefined && concentrationValue !== undefined) {
                concentrationData.push({ surface: surfaceValue, concentration: concentrationValue, XPos: XPos, YPos: YPos});
                saveToIndexedDB(JSON.stringify(concentrationData), 'concentrationData');
            }
            displayConcentrationData();
        }

        // Funkcja czyszcząca dane o stężeniach
        function clearConcentration() {
            concentrationData = [];
            saveToIndexedDB(JSON.stringify(concentrationData), 'concentrationData');
            displayConcentrationData();
        }

        // Funkcja wyświetlająca dane o stężeniach w formie tabeli
        function displayConcentrationData() {
            const container = document.getElementById("concentration_dataset");
            if (!container) return;

            container.innerHTML = "";
            container.style.border = '1px solid black';
            container.style.padding = '5px';

            const table = document.createElement("table");
            table.style.borderCollapse = "collapse";
            table.style.width = "100%";

            // Styl komórek
            const addCellStyle = (cell, isHeader = false) => {
                cell.style.border = "1px solid black";
                cell.style.padding = "4px";
                cell.style.verticalAlign = "middle";
                if (isHeader) {
                    cell.style.fontWeight = "bold";
                    cell.style.textAlign = "center";
                }
            };

            concentrationData.forEach((entry, index) => {
                const sampleNumber = index + 1;

                const labels = ["Surface:", "X:", "Y:", "Concentration:"];
                const values = [entry.surface, entry.XPos, entry.YPos, entry.concentration];

                labels.forEach((label, i) => {
                    const row = document.createElement("tr");

                    // Pierwsza kolumna — Sample 1 (scalona na 4 wiersze)
                    if (i === 0) {
                        const sampleCell = document.createElement("td");
                        sampleCell.rowSpan = labels.length;
                        sampleCell.textContent = `Sample ${sampleNumber}`;
                        sampleCell.style.textAlign = "center";
                        addCellStyle(sampleCell, true);
                        row.appendChild(sampleCell);
                    }

                    // Druga kolumna — etykieta
                    const labelCell = document.createElement("td");
                    labelCell.textContent = label;
                    if (label === "Concentration:") labelCell.style.fontWeight = "bold";
                    addCellStyle(labelCell);
                    row.appendChild(labelCell);

                    // Trzecia kolumna — wartość
                    const valueCell = document.createElement("td");
                    valueCell.textContent = values[i];
                    if (label === "Concentration:") valueCell.style.fontWeight = "bold";
                    addCellStyle(valueCell);
                    row.appendChild(valueCell);

                    table.appendChild(row);
                });
            });

            container.appendChild(table);
        }


        function calculateLinearRegression() {
            if (concentrationData.length < 2) return;
            
            const x = concentrationData.map(d => d.surface / referenceSurface);
            const y = concentrationData.map(d => d.concentration);
            
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.map((xi, i) => xi * y[i]).reduce((a, b) => a + b, 0);
            const sumX2 = x.map(xi => xi ** 2).reduce((a, b) => a + b, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX ** 2);
            const intercept = (sumY - slope * sumX) / n;
            
            const meanY = sumY / n;
            const ssTot = y.map(yi => (yi - meanY) ** 2).reduce((a, b) => a + b, 0);
            const ssRes = y.map((yi, i) => (yi - (slope * x[i] + intercept)) ** 2).reduce((a, b) => a + b, 0);
            const rSquared = 1 - ssRes / ssTot;
            
            concentrationCurve = { slope, intercept, rSquared };
            saveToIndexedDB(JSON.stringify(concentrationCurve), 'concentrationCurve');
            
            showConcentrationCurve();
        }

        function showConcentrationCurve() {
            const equationDiv = document.getElementById('LinearRegression');
            equationDiv.innerHTML = `
                <math>
                    <mrow>
                        <mi>y</mi><mo>=</mo>
                        <mn>${concentrationCurve.slope.toFixed(4)}</mn>
                        <mo>&#183;</mo><mi>x</mi>
                        <mo>+</mo><mn>${concentrationCurve.intercept.toFixed(4)}</mn>
                    </mrow>
                </math>
                <br>
                <math>
                    <mrow>
                        <msup><mi>R</mi><mn>2</mn></msup>
                        <mo>=</mo>
                        <mn>${concentrationCurve.rSquared.toFixed(4)}</mn>
                    </mrow>
                </math>
            `;
        }


        function predictConcentration(surface) {
            if (!concentrationCurve.slope || !concentrationCurve.intercept) return null;
            return concentrationCurve.slope * surface + concentrationCurve.intercept;
        }

        // Tworzenie siatki 3D na podstawie punktów (XPos, YPos, surface)
        function createBicubicSpline3D(points) {
            const xs = [...new Set(points.map(p => p.XPos))].sort((a, b) => a - b);
            const ys = [...new Set(points.map(p => p.YPos))].sort((a, b) => a - b);
            const surfaces = [...new Set(points.map(p => p.surface))].sort((a, b) => a - b);
            const grid = {};

            points.forEach(p => {
                if (!grid[p.XPos]) grid[p.XPos] = {};
                if (!grid[p.XPos][p.YPos]) grid[p.XPos][p.YPos] = {};
                grid[p.XPos][p.YPos][p.surface] = p.concentration;
            });

            return { xs, ys, surfaces, grid };
        }

        function evaluateSpline3D(spline, x, y, surface) {
    const { xs, ys, surfaces, grid } = spline;

    function getBoundingPoints(array, value) {
        if (value <= array[0]) {
            return [array[0], array[1] ?? array[0]]; // Ekstrapolacja dolna
        } else if (value >= array[array.length - 1]) {
            return [array[array.length - 2] ?? array[array.length - 1], array[array.length - 1]]; // Ekstrapolacja górna
        } else {
            let i = array.findIndex(v => v >= value);
            return [array[i - 1], array[i]];
        }
    }

    let [x0, x1] = getBoundingPoints(xs, x);
    let [y0, y1] = getBoundingPoints(ys, y);
    let [surface0, surface1] = getBoundingPoints(surfaces, surface);

    function getValue(x, y, s) {
        return grid[x]?.[y]?.[s] ?? 0;
    }

    let Q111 = getValue(x0, y0, surface0);
    let Q112 = getValue(x0, y0, surface1);
    let Q121 = getValue(x0, y1, surface0);
    let Q122 = getValue(x0, y1, surface1);
    let Q211 = getValue(x1, y0, surface0);
    let Q212 = getValue(x1, y0, surface1);
    let Q221 = getValue(x1, y1, surface0);
    let Q222 = getValue(x1, y1, surface1);

    function interpolate(v0, v1, x0, x1, x) {
        return v0 + ((v1 - v0) / (x1 - x0)) * (x - x0);
    }

    let R11 = interpolate(Q111, Q112, surface0, surface1, surface);
    let R12 = interpolate(Q121, Q122, surface0, surface1, surface);
    let R21 = interpolate(Q211, Q212, surface0, surface1, surface);
    let R22 = interpolate(Q221, Q222, surface0, surface1, surface);

    let r1 = interpolate(R11, R21, x0, x1, x);
    let r2 = interpolate(R12, R22, x0, x1, x);

    return interpolate(r1, r2, y0, y1, y);
}


        // Główna funkcja do przygotowania splajnu 3D
        function PreparePositionalCurve() {
            if (concentrationData.length < 2) return;

            normalizationParams = createBicubicSpline3D(concentrationData);
            console.log("3d spline ready!");

            // Przykładowe przewidywanie wartości w (0.5, 0.5, 0.5)
            console.log("normalization curve: ", normalizationParams);
            console.log("normalization curve: ", evaluateSpline3D(normalizationParams, 0.5, 0.5, 2623319));
            saveToIndexedDB(JSON.stringify(normalizationParams), 'normalizationParams');
        }


    </script>     
</body>
</html>