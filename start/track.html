<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas z IndexedDB</title>
    <script src="https://daybrush.com/moveable/release/latest/dist/moveable.min.js"></script>
    <link rel="stylesheet" href="pushdata.css">
    <style>
        canvas{
            border: solid black 1px;
        }

        #canvas_space{
            display: none;
        }
    </style>
</head>
<body>
    <script>
        // starter script
        function setBodyClassBasedOnScreenSize() {
            const dpi = window.devicePixelRatio || 1;
            const screenWidthInches = (window.innerWidth / dpi) / 96; // 96 dpi as standard
            const screenHeightInches = (window.innerHeight / dpi) / 96;
            const screenDiagonalInches = Math.sqrt(Math.pow(screenWidthInches, 2) + Math.pow(screenHeightInches, 2));
            const screenDiagonalMM = screenDiagonalInches * 25.4; // Convert inches to millimeters
            
            document.body.classList.remove("small-screen", "medium-screen", "large-screen");
            
            if (screenDiagonalMM < 180) { 
                document.body.classList.add("small-screen");
            } else if (screenDiagonalMM >= 180 && screenDiagonalMM < 330) { 
                document.body.classList.add("medium-screen");
            } else {
                document.body.classList.add("large-screen");
            }
        }
        window.onresize = setBodyClassBasedOnScreenSize;
        setBodyClassBasedOnScreenSize();
    </script>

    <div class="controls">
        <h3 id="konsola">konsola: </h3>
        <label for="treshold" title="Ustaw pr√≥g powy≈ºej kt√≥rego piksele bƒôdƒÖ zaliczone do t≈Ça i wybielone">Pr√≥g</label>
        <input type="number" id="treshold" min="0" max="255" step="1" value="240">
        <label for="kernelSize" title="Kernel dla blurr - do wykrywania granic peaku">blur</label>
        <input type="number" id="kernelSize" min="1" max="20" step="1" value="5">
        <button onclick="autostart()" title="Ponowne przetwarzanie danych po korekcie">üîÑ</button>
        <button onclick="unselectElement()" title="Odznacz wybrany element">‚ùå</button>
        <button onclick="removeSelectedElement()" title="Usu≈Ñ wybrany element">üóëÔ∏è</button>
        <button onclick="addDraggableElement()" title="Utw√≥rz nowƒÖ ≈õcie≈ºkƒô">‚ûï</button>
        <button id="toggleBtn" title="Poka≈º/Ukryj obszar rysowania" onclick="toggle_CanvasSpace()">‚áÑ</button>
        <button id="calculate" title="Uruchamia obliczenia" onclick="countParams()">üî¢</button>
        <label for="degree"  title="Stopie≈Ñ wielomianu">Stopie≈Ñ</label>
        <input id="degree" type="number" min="3" value="4" max="6" step="1">
        <a href="normaliser.html">‚Üê Normalise</a>
        <a href="setting.html">‚Üí Settings</a>
    </div>
    <div id="canvas_space">
        <h2>Spots image</h2>
        <canvas id="spots" width="400" height="400"></canvas>

        <h2>Background image</h2>
        <canvas id="background" width="400" height="400"></canvas>

        <h2>Normalised Canvas</h2>
        <canvas id="normalised" width="400" height="400"></canvas>
    </div>
    <div id="track_space"></div>
    <div id="parameterBox"></div>

    </div> 
    <!-- internalize script --><script src="internalize.js"></script><!-- internalize script -->

    <script>
        // Zmienne globalne
        let baselines = null;
        let draggable_coordinates = null;
        let selectedTrack = null;
        let manuals = false;

        function toggle_CanvasSpace(){
            const canvasSpace = document.getElementById("canvas_space");
            canvasSpace.style.display = (canvasSpace.style.display === "none") ? "block" : "none";
        }

        // Funkcja do pobrania i parsowania danych JSON z IndexedDB
        function loadJsonDataFromIndexedDB(dbName, storeName, key) {
            return new Promise((resolve, reject) => {
                // Pobierz dane JSON z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((jsonData) => {
                    try {
                        // Parsowanie danych JSON
                        const parsedData = JSON.parse(jsonData);
                        console.log(parsedData);
                        // Przypisanie danych do odpowiednich zmiennych globalnych
                        if (key === "baselines") {
                            baselines = parsedData;
                        } else if (key === "draggable_coordinates") {
                            draggable_coordinates = parsedData;
                        }

                        // Zwr√≥ƒá Promise po udanym za≈Çadowaniu
                        resolve();
                    } catch (error) {
                        reject(`B≈ÇƒÖd podczas parsowania danych JSON: ${error}`);
                    }
                }).catch((error) => {
                    console.error('B≈ÇƒÖd podczas ≈Çadowania danych z IndexedDB:', error);
                    reject(error);
                });
            });
        }

        // Funkcja do wstawienia obrazu na odpowiedni canvas
        function loadImageToCanvas(dbName, storeName, key, canvasId) {
            return new Promise((resolve, reject) => {
                // Pobierz URL obrazu z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((imageUrl) => {
                    // Znajd≈∫ odpowiedni element canvas
                    const canvas = document.getElementById(canvasId);
                    if (canvas && imageUrl) {
                        const img = new Image();
                        img.onload = () => {
                            // Ustaw rozmiar canvasu na rozmiar obrazu
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // Rysuj obraz na canvas
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(img, 0, 0);  // Wstaw obraz na canvas

                            // Zwr√≥ƒá Promise po za≈Çadowaniu obrazu
                            resolve();
                        };
                        img.src = imageUrl;  // Ustaw ≈∫r√≥d≈Ço obrazu
                    } else {
                        reject('B≈ÇƒÖd przy ≈Çadowaniu obrazu.');
                    }
                }).catch((error) => {
                    console.error('B≈ÇƒÖd podczas ≈Çadowania obrazu:', error);
                    reject(error);
                });
            });
        }

        // Funkcja, kt√≥ra ma byƒá uruchomiona po za≈Çadowaniu obu obraz√≥w
        function onAllDataLoaded() {
            normalizeCanvasData();
            extractTrackData(draggable_coordinates, baselines);
            countParams();
        }

        function autostart() {
            const dbName = "TLC";
            const storeName = "data";

            // ≈Åadowanie obu obraz√≥w jednocze≈õnie
            Promise.all([
                loadImageToCanvas(dbName, storeName, "spots", "spots"),
                loadImageToCanvas(dbName, storeName, "background", "background"),
                loadJsonDataFromIndexedDB(dbName, storeName, "baselines"),
                loadJsonDataFromIndexedDB(dbName, storeName, "draggable_coordinates")
            ]).then(() => {
                // Po za≈Çadowaniu obu obraz√≥w uruchom funkcjƒô
                onAllDataLoaded();
            }).catch((error) => {
                console.error("WystƒÖpi≈Ç b≈ÇƒÖd podczas ≈Çadowania obraz√≥w:", error);
            });            
        }

        // ≈Åadowanie obraz√≥w na kanwasy po za≈Çadowaniu strony
        window.onload = () => {
            autostart();
        };

        function normalizeCanvasData() {
            // Pobierz referencje do canvas√≥w
            const spotsCanvas = document.getElementById("spots");
            const backgroundCanvas = document.getElementById("background");

            // Sprawd≈∫, czy oba canvas majƒÖ takie same wymiary
            if (spotsCanvas.width !== backgroundCanvas.width || spotsCanvas.height !== backgroundCanvas.height) {
                alert("Canvas majƒÖ r√≥≈ºne wymiary! Upewnij siƒô, ≈ºe oba canvas majƒÖ te same wymiary.");
                return;
            }

            // Pobierz ImageData z obu canvas√≥w
            const spotsContext = spotsCanvas.getContext("2d");
            const backgroundContext = backgroundCanvas.getContext("2d");

            const spotsImageData = spotsContext.getImageData(0, 0, spotsCanvas.width, spotsCanvas.height);
            const backgroundImageData = backgroundContext.getImageData(0, 0, backgroundCanvas.width, backgroundCanvas.height);

            // Przygotuj nowy canvas na wynik
            const normalizedCanvas = document.getElementById("normalised");
            normalizedCanvas.width = spotsCanvas.width;
            normalizedCanvas.height = spotsCanvas.height;
            const normalizedContext = normalizedCanvas.getContext("2d");
            const normalizedImageData = normalizedContext.createImageData(spotsCanvas.width, spotsCanvas.height);

            const treshold = parseInt(document.getElementById('treshold').value);
            // Przetw√≥rz piksel po pikselu
            for (let i = 0; i < spotsImageData.data.length; i += 4) {
                const rSpots = spotsImageData.data[i];     // Czerwony kana≈Ç z spots
                const rBackground = backgroundImageData.data[i]; // Czerwony kana≈Ç z background

                // Podziel kana≈Ç czerwony spots przez kana≈Ç czerwony background i przemn√≥≈º przez 255
                let rNormalized;
                if (rBackground === 0) {
                    rNormalized = 255; // Unikaj dzielenia przez zero
                } else {
                    rNormalized = (rSpots / rBackground) * 255;
                }

                // Ustaw ograniczenie na warto≈õƒá z input
                rNormalized = rNormalized > treshold ? 255 : rNormalized;

                // Ustaw wynik dla wszystkich kana≈Ç√≥w (RGB)
                normalizedImageData.data[i] = rNormalized;        // R
                normalizedImageData.data[i + 1] = rNormalized;    // G
                normalizedImageData.data[i + 2] = rNormalized;    // B
                normalizedImageData.data[i + 3] = 255;            // A (pe≈Çna przezroczysto≈õƒá)
            }

            // Wstaw ImageData do canvasu "normalised"
            normalizedContext.putImageData(normalizedImageData, 0, 0);
        }

        // Function to blur an array using a kernel size
        function blurArray(inputArray, kernelSize) {
            const outputArray = new Array(inputArray.length).fill(0);
            const halfKernel = Math.floor(kernelSize / 2);

            for (let i = 0; i < inputArray.length; i++) {
                let sum = 0;
                let count = 0;

                for (let k = -halfKernel; k <= halfKernel; k++) {
                    const idx = i + k;
                    if (idx >= 0 && idx < inputArray.length) {
                        sum += inputArray[idx];
                        count++;
                    }
                }
                if (inputArray[i] === 0) {
                outputArray[i] = 0;
                }
                else{
                outputArray[i] = sum / count;
                }
            }
            return outputArray;
        }

        function analyzeArrayWithKernel(array, kernelSize, height) {
            const mountains = [];
            let status = "constant"; // Possible values: "constant", "ascending", "descending"
            let mountainStart = null;
            let mountainEnd = null;

            for (let i = 0; i < array.length; i++) {
                // Get neighbors to the right based on kernel size
                const neighbors = [];
                for (let k = 1; k <= kernelSize; k++) {
                    if (i + k < array.length) {
                        neighbors.push(array[i + k]);
                    }
                }

                // Calculate the average of neighbors
                const average = neighbors.length > 0 
                    ? neighbors.reduce((sum, val) => sum + val, 0) / neighbors.length
                    : 0;

                // Determine the new status based on comparison with average
                let newStatus;
                if (array[i] > average) {
                    newStatus = "descending";
                } else if (array[i] < average) {
                    newStatus = "ascending";
                } else {
                    newStatus = "constant";
                }

                // Handle status change logic
                if (newStatus !== status) {
                    if ((status === "constant" || status === "descending") && newStatus === "ascending" ) {
                    if (mountainStart !== null) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = i;
                        mountainEnd = null;                
                    }
                    else{
                        mountainStart = mountainStart === null ? i : mountainStart;
                    }
                        
                    } 
                    else if (status === "descending" && mountainStart !== null && (newStatus === "constant" )) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = null;
                        mountainEnd = null;
                    }          

                    // Update status
                    //console.log(status, newStatus);
                    status = newStatus;
                    
                }
            }
            // Find the global minimum and maximum values in arr
            const globalMin = Math.min(...array);
            const globalMax = Math.max(...array);
            const globalDistance = globalMax - globalMin;
            // Validate and extract real mountains
            const realMountains = mountains.filter(({ start, end }) => {
            const fragment = array.slice(start, end + 1); // Get the fragment of arr
            const fragmentMin = Math.min(...fragment);
            const fragmentMax = Math.max(...fragment);
            const fragmentDistance = fragmentMax - fragmentMin;

            // Compare fragment distance to x% of global distance
            return fragmentDistance >= (height / 100) * globalDistance;
            });
            return realMountains;
        }

        function extractTrackData(draggable_coordinates, baselines) {
            // Uzyskanie dostƒôpu do g≈Ç√≥wnego canvas
            const normCanvas = document.getElementById('normalised');
            const normCtx = normCanvas.getContext('2d');
            const kernelSize = parseInt(document.getElementById('kernelSize').value);
            const track_space = document.getElementById('track_space');
            track_space.innerHTML = '';
            draggable_coordinates.forEach(coordinate => {
                // Wydobywanie danych z ImageData dla podanych wsp√≥≈Çrzƒôdnych
                const imageData = normCtx.getImageData(baselines.x, coordinate.y, baselines.width, coordinate.height);
                // Tworzenie nowego canvas i kontekstu
                const newCanvas = document.createElement('canvas');
                const newCtx = newCanvas.getContext('2d');

                // Ustawianie rozmiaru nowego canvas
                newCanvas.width = baselines.width;
                newCanvas.height = coordinate.height;

                // Wstawianie ImageData do nowego canvas
                newCtx.putImageData(imageData, 0, 0);

                // Tworzenie nowego div'a z odpowiednim id
                const newDiv = document.createElement('div');
                newDiv.style.position = 'relative';
                newDiv.classList.add("track");
                newDiv.id = coordinate.name;  // Ustawianie id div'a na podstawie 'name' w draggable_coordinates

                // Tworzenie tablicy 1D z sumami kana≈Çu czerwonego dla ka≈ºdej kolumny
                const RedSums = [];
                for (let x = 0; x < imageData.width; x++) {
                    let sumRed = 0;
                    for (let y = 0; y < imageData.height; y++) {
                        const index = (y * imageData.width + x) * 4;
                        sumRed += 255 - imageData.data[index]; // Kana≈Ç czerwony to pierwszy element w tablicy (index * 4)
                    }

                    RedSums.push(sumRed); // Zapisanie sumy kana≈Çu czerwonego dla ka≈ºdej kolumny
                }
                
                const blurredRedSums = blurArray(RedSums, kernelSize);
                const mountains = analyzeArrayWithKernel(blurredRedSums, 1, 1);
                console.log(mountains);
                // Normalizacja RedSums (zak≈ÇadajƒÖc, ≈ºe minimalna warto≈õƒá to 0, a maksymalna to 250)
                const min = Math.min(...RedSums);
                const max = Math.max(...RedSums);
                const normalizedRedSums = RedSums.map(value => (value - min) / (max - min) * 250);
                
                // Dodanie atrybutu data-red-sums do div'a z 1D tablicƒÖ RedSums
                newDiv.dataset.RedSums = JSON.stringify(RedSums);  // U≈ºycie data-* atrybutu
                //newDiv.dataset.blurredSums = JSON.stringify(blurredRedSums); 
                // Tworzenie g≈Ç√≥wnego canvas
                const mainCanvas = document.createElement('canvas');
                mainCanvas.classList.add('chart');
                mainCanvas.width = newCanvas.width;
                mainCanvas.height = 250;
                const ctx = mainCanvas.getContext('2d');

                // Rysowanie wykresu jako linia
                ctx.beginPath();
                ctx.strokeStyle = 'steelblue';
                ctx.lineWidth = 2;
                normalizedRedSums.forEach((value, index) => {
                    const x = (index / (normalizedRedSums.length - 1)) * mainCanvas.width;
                    const y = 250 - value;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                const header = document.createElement('h2');
                header.textContent = coordinate.name;
                newDiv.appendChild(header);
                // Dodanie canvas z wykresem do div'a
                newDiv.appendChild(mainCanvas);

                // Dodanie br pomiƒôdzy canvasami
                const br = document.createElement('br');
                newDiv.appendChild(br);

                // Dodanie canvas do div'a
                newDiv.appendChild(newCanvas);

                // Dodanie div'a do dokumentu (np. do body)
                track_space.appendChild(newDiv);

                // Pobranie pozycji newDiv
                const newDivRect = newDiv.getBoundingClientRect();
                const mainCanvasRect = mainCanvas.getBoundingClientRect();
                const newCanvasRect = newCanvas.getBoundingClientRect();

                // Obliczenie wysoko≈õci od g√≥ry mainCanvas do do≈Çu newCanvas wzglƒôdem newDiv
                const totalHeight = newCanvasRect.bottom - mainCanvasRect.top;

                // Tworzenie div√≥w dla ka≈ºdego obiektu w mountains
                mountains.forEach(({ start, end }) => {
                    const mountainDiv = document.createElement('div');
                    
                    mountainDiv.style.position = 'absolute';
                    mountainDiv.style.left = `${start - newDivRect.left}px`;  // Wzglƒôdem newDiv
                    mountainDiv.style.width = `${end - start}px`;
                    mountainDiv.style.top = `${mainCanvasRect.top - newDivRect.top}px`; // Wzglƒôdem newDiv
                    mountainDiv.style.height = `${totalHeight}px`;
                    mountainDiv.style.backgroundColor = 'rgba(0, 0, 255, 0.3)'; // Przezroczysty kolor dla widoczno≈õci

                    newDiv.appendChild(mountainDiv);
                    createDraggableElement(newDiv, mountainDiv);
                });

            });
        }

        function addDraggableElement() {
            const element = selectedTrack.target;
            const container = element.parentElement;
            //const RectContainer = container.getBoundingClientRect();
            const mountainDiv = document.createElement('div');
                    
            mountainDiv.style.position = 'absolute';
            mountainDiv.style.left = element.style.left;
            mountainDiv.style.width = element.style.width;
            mountainDiv.style.top = element.style.top;
            mountainDiv.style.height = element.style.height;
            mountainDiv.style.backgroundColor = 'rgba(0, 0, 255, 0.3)'; // Przezroczysty kolor dla widoczno≈õci
            container.appendChild(mountainDiv);
            createDraggableElement(container, mountainDiv);
        }

        // Moveable setup
        function createDraggableElement(container, element) {
            if (!container) return;
            const containerHeight = container.getBoundingClientRect().height;
            element.classList.add("draggable");
            
            const movable = new Moveable(container, {
                target: element,
                draggable: true,
                throttleDrag: 1,
                edgeDraggable: false,
                startDragRotate: 0,
                throttleDragRotate: 0,
                resizable: true,
                keepRatio: false,
                throttleResize: 1,
                renderDirections:  ["w", "e"],
                bounds: { left: 0, right: 0 }        
            });
            movable.on("drag", e => {
                e.target.style.left = `${e.left}px`;
            });
            movable.on("resize", e => {
                e.target.style.width = `${e.width}px`;
                e.target.style.transform = e.drag.transform;
            });
            movable.on("click", e => {
                resetDraggablesColor();
                selectedTrack = {target: e.target, moveable: e.moveable};
                e.target.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                updateParameterBox();
            });
        }

        function resetDraggablesColor() {
            document.querySelectorAll(".draggable").forEach(el => {
                el.style.backgroundColor = 'rgba(0, 0, 255, 0.3)';
            });
        }

        function unselectElement(){
            selectedTrack = null;
            resetDraggablesColor();
        }

        function removeSelectedElement() {
            if (selectedTrack) {
                selectedTrack.moveable.controlBox.remove();
                selectedTrack.moveable.destroy();
                selectedTrack.target.remove();
                selectedTrack = null;
            }
        }

        // Implementacja interpolacji splajn√≥w kubicznych w czystym JS
        class CubicSpline {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.n = x.length - 1;
                this.h = [];
                this.b = [];
                this.c = new Array(this.n + 1).fill(0);
                this.d = new Array(this.n).fill(0);

                for (let i = 0; i < this.n; i++) {
                    this.h[i] = x[i + 1] - x[i];
                }

                let alpha = new Array(this.n).fill(0);
                for (let i = 1; i < this.n; i++) {
                    alpha[i] = (3 / this.h[i]) * (y[i + 1] - y[i]) - (3 / this.h[i - 1]) * (y[i] - y[i - 1]);
                }

                let l = new Array(this.n + 1).fill(1);
                let mu = new Array(this.n).fill(0);
                let z = new Array(this.n + 1).fill(0);

                for (let i = 1; i < this.n; i++) {
                    l[i] = 2 * (x[i + 1] - x[i - 1]) - this.h[i - 1] * mu[i - 1];
                    mu[i] = this.h[i] / l[i];
                    z[i] = (alpha[i] - this.h[i - 1] * z[i - 1]) / l[i];
                }

                for (let j = this.n - 1; j >= 0; j--) {
                    this.c[j] = z[j] - mu[j] * this.c[j + 1];
                    this.b[j] = (y[j + 1] - y[j]) / this.h[j] - this.h[j] * (this.c[j + 1] + 2 * this.c[j]) / 3;
                    this.d[j] = (this.c[j + 1] - this.c[j]) / (3 * this.h[j]);
                }
            }

            at(xi) {
                if (xi < this.x[0]) {
                    return this.y[0]; // Je≈õli xi jest poza zakresem, zwr√≥ƒá warto≈õƒá na poczƒÖtku
                }
                if (xi > this.x[this.n]) {
                    return this.y[this.n]; // Je≈õli xi jest poza zakresem, zwr√≥ƒá warto≈õƒá na ko≈Ñcu
                }

                let i = this.x.findIndex((val, index) => index < this.n && this.x[index + 1] > xi);
                if (i === -1) i = this.n - 1;

                let dx = xi - this.x[i];
                return this.y[i] + this.b[i] * dx + this.c[i] * dx ** 2 + this.d[i] * dx ** 3;
            }
        }

        function cubicSplineInterpolationAndExtrapolate(data, start, end) {
            const midpoint = findMidpointIndex(data, start, end);

            const xLeft = Array.from({ length: midpoint - start + 1 }, (_, i) => start + i);
            const yLeft = xLeft.map(i => data[i]);
            const splineLeft = new CubicSpline(xLeft, yLeft);

            const xRight = Array.from({ length: end - midpoint + 1 }, (_, i) => midpoint + i);
            const yRight = xRight.map(i => data[i]);
            const splineRight = new CubicSpline(xRight, yRight);

            function predictLeft(xi) {
                return splineLeft.at(xi);
            }

            function predictRight(xi) {
                return splineRight.at(xi);
            }

            let extendedData = [...data];

            let nextIndex = end + 1;
            while (predictRight(nextIndex) > 0) {
                extendedData[nextIndex] = predictRight(nextIndex);
                nextIndex++;
            }

            let prevIndex = start - 1;
            while (prevIndex >= 0 && predictLeft(prevIndex) > 0) {
                extendedData[prevIndex] = predictLeft(prevIndex);
                prevIndex--;
            }

            return { data: extendedData, newStart: prevIndex + 1, newEnd: nextIndex - 1 };
        }



        function findMidpointIndex(data, start, end) {
            const maxVal = Math.max(...data.slice(start, end + 1));
            const maxIndices = [];

            for (let i = start; i <= end; i++) {
                if (data[i] === maxVal) {
                    maxIndices.push(i);
                }
            }

            return Math.round(maxIndices.reduce((sum, i) => sum + i, 0) / maxIndices.length);
        }        

        function extendPeaks(){
            document.querySelectorAll(".track").forEach(track => {
                let redSums = JSON.parse(track.dataset.RedSums);
                let canvas = track.querySelector(".chart");
                let ctx = canvas.getContext("2d");

                track.querySelectorAll(".draggable").forEach(draggable => {
                    const Rect = draggable.getBoundingClientRect();
                    let start = parseInt(Rect.left) || 0;
                    let end = parseInt(Rect.width) + parseInt(Rect.left) || redSums.length;
                    //let degree = parseInt(document.getElementById("degree").value);
                    
                    let result = cubicSplineInterpolationAndExtrapolate(redSums, start, end);
                    result.data = result.data.slice(result.newStart, result.newEnd);
                    let normalizedData = result.data.map(v => (v / Math.max(...redSums)) * 250);
                    draggable.dataset.result = JSON.stringify(result);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = "red";
                    ctx.lineWidth = 2;
                    
                    normalizedData.forEach((val, i) => {
                        let x = i + result.newStart;
                        let y = canvas.height - val;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    ctx.stroke();
                }); 
            });        
        }
    
        function countParams() {
            document.querySelectorAll(".track").forEach(track => {
                let redSums = JSON.parse(track.dataset.RedSums);
                const maxHeight = Math.max(...redSums); // Maksymalna warto≈õƒá w redSums

                track.querySelectorAll(".draggable").forEach(draggable => {
                    const rect = draggable.getBoundingClientRect();
                    let start = parseInt(rect.left) || 0;
                    let end = parseInt(rect.width) + parseInt(rect.left) || redSums.length;
                    const data = redSums.slice(start, end);
                    const midpointIndex = findMidpointIndex(redSums, start, end);
                    const peakMaxHeight = Math.max(...data);
                    const peakMaxHeightPercent = (peakMaxHeight / maxHeight) * 100;

                    const getWidthAtHeight = (heightFraction) => {
                        let threshold = peakMaxHeight * heightFraction;
                        let left = start;
                        let right = end - 1;
                        
                        while (left < end && redSums[left] < threshold) left++;
                        while (right > start && redSums[right] < threshold) right--;
                        
                        return right - left;
                    };

                    const Wbas = getWidthAtHeight(0);
                    const W50 = getWidthAtHeight(0.5);
                    const W10 = getWidthAtHeight(0.1);
                    const W05 = getWidthAtHeight(0.05);
                    const surface = data.reduce((sum, val) => sum + val, 0);

                    const getDistanceAtHeight = (heightFraction) => {
                        let threshold = peakMaxHeight * heightFraction;
                        let left = start;
                        let right = end - 1;
                        
                        while (left < end && redSums[left] < threshold) left++;
                        while (right > start && redSums[right] < threshold) right--;
                        
                        return {
                            A: midpointIndex - left,
                            B: right - midpointIndex
                        };
                    };

                    const A05 = getDistanceAtHeight(0.05).A;
                    const A10 = getDistanceAtHeight(0.10).A;
                    const B05 = getDistanceAtHeight(0.05).B;
                    const B10 = getDistanceAtHeight(0.10).B;
                    const asymmetryFactor = B10 / A10;
                    const tailingFactor = W05 / (2 * A05);

                    const params = JSON.stringify({
                        midpointIndex: { value: midpointIndex, description: "Index of midpoint" },
                        maxHeight: { value: maxHeight, description: "Maximal height on track" },
                        peakMaxHeight: { value: peakMaxHeight, description: "Maximal height of peak" },
                        peakMaxHeightPercent: { value: peakMaxHeightPercent, description: "Maximal height of peak / Maximal height on track * 100%" },
                        Wbas: { value: Wbas, description: "Width of peak at 0% of height" },
                        W50: { value: W50, description: "Width of peak at 50% of height" },
                        W10: { value: W10, description: "Width of peak at 10% of height" },
                        W05: { value: W05, description: "Width of peak at 5% of height" },
                        surface: { value: surface, description: "Surface of spot" },
                        A05: { value: A05, description: "Start to midpoint distance at 5% of height" },
                        A10: { value: A10, description: "Start to midpoint distance at 10% of height" },
                        B05: { value: B05, description: "Midpoint to end distance at 5% of height" },
                        B10: { value: B10, description: "Midpoint to end distance at 10% of height" },
                        asymmetryFactor: { value: asymmetryFactor, description: "Asymmetry factor" },
                        tailingFactor: { value: tailingFactor, description: "Tailing factor" }
                    });

                    draggable.dataset.params = params;
                });
            });
            // count secondary params
            countSecondaryParams();
        }

        function countSecondaryParams() {
            document.querySelectorAll(".track").forEach(track => {
                let redSums = JSON.parse(track.dataset.RedSums);

                track.querySelectorAll(".draggable").forEach(draggable => {

                    let params = JSON.parse(draggable.dataset.params);
                    params.plate_width = { 
                        value: baselines.plate_width, // globalna zmienna
                        description: "Plate width in cm"
                    };
                    consloe.log(params);
                    const spotsElement = document.getElementById('spots');
                    if (spotsElement) {
                        params.track_width = { 
                            value: (redSums.length / spotsElement.width) * params.plate_width, 
                            description: "Track width in cm"
                        };
                    } else {
                        console.error("Element #spots nie istnieje");
                    }

                    params.RF = { 
                        value: params.midpointIndex / redSums.length, 
                        description: "Retention Factor"
                    };

                    params.k = { 
                        value: (1 - params.RF) / params.RF, 
                        description: "K param" 
                    };

                    params.RM = { 
                        value: Math.log10(params.k), 
                        description: "RM param"
                    };

                    params.HobsBAS = { 
                        value: (params.Wbas ** 2) / (5.54 * params.RF), 
                        description: "Hobs at basis - United States Pharmacopeia" 
                    };

                    params.Hobs05 = { 
                        value: (params.W50 ** 2) / (16 * params.RF), 
                        description: "Hobs at 50% of height - European Pharmacopeia" 
                    };

                    params.NobsBAS = { 
                        value: (16 * params.RF) / params.Wbas, 
                        description: "Nobs at basis - United States Pharmacopeia" 
                    };

                    params.Nobs05 = { 
                        value: (params.RF / params.W50) ** 2 * 5.54, 
                        description: "Nobs at 50% of height - European Pharmacopeia" 
                    };

                    params.N_mBAS = { 
                        value: params.NobsBAS / params.track_width, 
                        description: "N/m at basis - United States Pharmacopeia" 
                    };

                    params.N_m05 = { 
                        value: params.Nobs05 / params.track_width, 
                        description: "N/m at 50% of height - European Pharmacopeia" 
                    };

                    draggable.dataset.params = JSON.stringify(params);
                });
            });
        }


        function updateParameterBox() {
            const parameterBox = document.getElementById('parameterBox');
            parameterBox.innerHTML = "";

            if (!selectedTrack || !selectedTrack.target) return;
            
            const paramsData = selectedTrack.target.dataset.params;
            if (!paramsData) return;
            
            try {
                const paramsObject = JSON.parse(paramsData);
                if (typeof paramsObject !== "object" || paramsObject === null) return; // Ensure it's an object

                const list = document.createElement("ul");

                Object.entries(paramsObject).forEach(([key, param]) => {
                    if (typeof param !== "object" || !param.hasOwnProperty("description") || !param.hasOwnProperty("value")) return;

                    const listItem = document.createElement("li");
                    const label = document.createElement("label");
                    label.textContent = param.description;

                    const input = document.createElement("input");
                    input.type = "number";
                    input.value = param.value;
                    input.dataset.paramKey = key; // Store key for later updates if needed

                    listItem.appendChild(label);
                    listItem.appendChild(input);
                    list.appendChild(listItem);
                });

                parameterBox.appendChild(list);
            } catch (e) {
                console.error("Error parsing paramsData:", e);
            }
        }



    </script>     
</body>
</html>