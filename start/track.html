<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas z IndexedDB</title>
    <script src="https://daybrush.com/moveable/release/latest/dist/moveable.min.js"></script>
    <link rel="stylesheet" href="pushdata.css">
    <style>
        canvas{
            border: solid black 1px;
        }
    </style>
</head>
<body>
    <script>
        // starter script
        function setBodyClassBasedOnScreenSize() {
            const dpi = window.devicePixelRatio || 1;
            const screenWidthInches = (window.innerWidth / dpi) / 96; // 96 dpi as standard
            const screenHeightInches = (window.innerHeight / dpi) / 96;
            const screenDiagonalInches = Math.sqrt(Math.pow(screenWidthInches, 2) + Math.pow(screenHeightInches, 2));
            const screenDiagonalMM = screenDiagonalInches * 25.4; // Convert inches to millimeters
            
            document.body.classList.remove("small-screen", "medium-screen", "large-screen");
            
            if (screenDiagonalMM < 180) { 
                document.body.classList.add("small-screen");
            } else if (screenDiagonalMM >= 180 && screenDiagonalMM < 330) { 
                document.body.classList.add("medium-screen");
            } else {
                document.body.classList.add("large-screen");
            }
        }
        window.onresize = setBodyClassBasedOnScreenSize;
        setBodyClassBasedOnScreenSize();
    </script>

    <div class="controls">
        <h3 id="konsola">konsola: </h3>
        <label for="treshold" title="Ustaw pr贸g powy偶ej kt贸rego piksele bd zaliczone do ta i wybielone">Pr贸g</label>
        <input type="number" id="treshold" min="0" max="255" step="1" value="240">
        <button onclick="autostart()" title="Ponowne przetwarzanie danych po korekcie"></button>
    </div>
    <h2>Spots image</h2>
    <canvas id="spots" width="400" height="400"></canvas>

    <h2>Background image</h2>
    <canvas id="background" width="400" height="400"></canvas>

    <h2>Normalised Canvas</h2>
    <canvas id="normalised" width="400" height="400"></canvas>

    <!-- internalize script --><script src="internalize.js"></script><!-- internalize script -->

    <script>
        // Zmienne globalne
        let baselines = null;
        let draggable_coordinates = null;

        // Funkcja do pobrania i parsowania danych JSON z IndexedDB
        function loadJsonDataFromIndexedDB(dbName, storeName, key) {
            return new Promise((resolve, reject) => {
                // Pobierz dane JSON z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((jsonData) => {
                    try {
                        // Parsowanie danych JSON
                        const parsedData = JSON.parse(jsonData);
                        console.log(parsedData);
                        // Przypisanie danych do odpowiednich zmiennych globalnych
                        if (key === "baselines") {
                            baselines = parsedData;
                        } else if (key === "draggable_coordinates") {
                            draggable_coordinates = parsedData;
                        }

                        // Zwr贸 Promise po udanym zaadowaniu
                        resolve();
                    } catch (error) {
                        reject(`Bd podczas parsowania danych JSON: ${error}`);
                    }
                }).catch((error) => {
                    console.error('Bd podczas adowania danych z IndexedDB:', error);
                    reject(error);
                });
            });
        }

        // Funkcja do wstawienia obrazu na odpowiedni canvas
        function loadImageToCanvas(dbName, storeName, key, canvasId) {
            return new Promise((resolve, reject) => {
                // Pobierz URL obrazu z IndexedDB
                getImageUrlFromIndexedDB(dbName, storeName, key).then((imageUrl) => {
                    // Znajd藕 odpowiedni element canvas
                    const canvas = document.getElementById(canvasId);
                    if (canvas && imageUrl) {
                        const img = new Image();
                        img.onload = () => {
                            // Ustaw rozmiar canvasu na rozmiar obrazu
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // Rysuj obraz na canvas
                            const ctx = canvas.getContext("2d");
                            ctx.drawImage(img, 0, 0);  // Wstaw obraz na canvas

                            // Zwr贸 Promise po zaadowaniu obrazu
                            resolve();
                        };
                        img.src = imageUrl;  // Ustaw 藕r贸do obrazu
                    } else {
                        reject('Bd przy adowaniu obrazu.');
                    }
                }).catch((error) => {
                    console.error('Bd podczas adowania obrazu:', error);
                    reject(error);
                });
            });
        }

        // Funkcja, kt贸ra ma by uruchomiona po zaadowaniu obu obraz贸w
        function onAllDataLoaded() {
            normalizeCanvasData();
            extractTrackData(draggable_coordinates, baselines);
        }

        function autostart() {
            const dbName = "TLC";
            const storeName = "data";

            // adowanie obu obraz贸w jednoczenie
            Promise.all([
                loadImageToCanvas(dbName, storeName, "spots", "spots"),
                loadImageToCanvas(dbName, storeName, "background", "background"),
                loadJsonDataFromIndexedDB(dbName, storeName, "baselines"),
                loadJsonDataFromIndexedDB(dbName, storeName, "draggable_coordinates")
            ]).then(() => {
                // Po zaadowaniu obu obraz贸w uruchom funkcj
                onAllDataLoaded();
            }).catch((error) => {
                console.error("Wystpi bd podczas adowania obraz贸w:", error);
            });            
        }

        // adowanie obraz贸w na kanwasy po zaadowaniu strony
        window.onload = () => {
            autostart();
        };

        function normalizeCanvasData() {
            // Pobierz referencje do canvas贸w
            const spotsCanvas = document.getElementById("spots");
            const backgroundCanvas = document.getElementById("background");

            // Sprawd藕, czy oba canvas maj takie same wymiary
            if (spotsCanvas.width !== backgroundCanvas.width || spotsCanvas.height !== backgroundCanvas.height) {
                alert("Canvas maj r贸偶ne wymiary! Upewnij si, 偶e oba canvas maj te same wymiary.");
                return;
            }

            // Pobierz ImageData z obu canvas贸w
            const spotsContext = spotsCanvas.getContext("2d");
            const backgroundContext = backgroundCanvas.getContext("2d");

            const spotsImageData = spotsContext.getImageData(0, 0, spotsCanvas.width, spotsCanvas.height);
            const backgroundImageData = backgroundContext.getImageData(0, 0, backgroundCanvas.width, backgroundCanvas.height);

            // Przygotuj nowy canvas na wynik
            const normalizedCanvas = document.getElementById("normalised");
            normalizedCanvas.width = spotsCanvas.width;
            normalizedCanvas.height = spotsCanvas.height;
            const normalizedContext = normalizedCanvas.getContext("2d");
            const normalizedImageData = normalizedContext.createImageData(spotsCanvas.width, spotsCanvas.height);

            const treshold = parseInt(document.getElementById('treshold').value);
            // Przetw贸rz piksel po pikselu
            for (let i = 0; i < spotsImageData.data.length; i += 4) {
                const rSpots = spotsImageData.data[i];     // Czerwony kana z spots
                const rBackground = backgroundImageData.data[i]; // Czerwony kana z background

                // Podziel kana czerwony spots przez kana czerwony background i przemn贸偶 przez 255
                let rNormalized;
                if (rBackground === 0) {
                    rNormalized = 255; // Unikaj dzielenia przez zero
                } else {
                    rNormalized = (rSpots / rBackground) * 255;
                }

                // Ustaw ograniczenie na warto z input
                rNormalized = rNormalized > treshold ? 255 : rNormalized;

                // Ustaw wynik dla wszystkich kana贸w (RGB)
                normalizedImageData.data[i] = rNormalized;        // R
                normalizedImageData.data[i + 1] = rNormalized;    // G
                normalizedImageData.data[i + 2] = rNormalized;    // B
                normalizedImageData.data[i + 3] = 255;            // A (pena przezroczysto)
            }

            // Wstaw ImageData do canvasu "normalised"
            normalizedContext.putImageData(normalizedImageData, 0, 0);
        }

        // Function to blur an array using a kernel size
        function blurArray(inputArray, kernelSize) {
            const outputArray = new Array(inputArray.length).fill(0);
            const halfKernel = Math.floor(kernelSize / 2);

            for (let i = 0; i < inputArray.length; i++) {
                let sum = 0;
                let count = 0;

                for (let k = -halfKernel; k <= halfKernel; k++) {
                    const idx = i + k;
                    if (idx >= 0 && idx < inputArray.length) {
                        sum += inputArray[idx];
                        count++;
                    }
                }
                if (inputArray[i] === 0) {
                outputArray[i] = 0;
                }
                else{
                outputArray[i] = sum / count;
                }
            }
            return outputArray;
        }

        function analyzeArrayWithKernel(array, kernelSize, height) {
            const mountains = [];
            let status = "constant"; // Possible values: "constant", "ascending", "descending"
            let mountainStart = null;
            let mountainEnd = null;

            for (let i = 0; i < array.length; i++) {
                // Get neighbors to the right based on kernel size
                const neighbors = [];
                for (let k = 1; k <= kernelSize; k++) {
                    if (i + k < array.length) {
                        neighbors.push(array[i + k]);
                    }
                }

                // Calculate the average of neighbors
                const average = neighbors.length > 0 
                    ? neighbors.reduce((sum, val) => sum + val, 0) / neighbors.length
                    : 0;

                // Determine the new status based on comparison with average
                let newStatus;
                if (array[i] > average) {
                    newStatus = "descending";
                } else if (array[i] < average) {
                    newStatus = "ascending";
                } else {
                    newStatus = "constant";
                }

                // Handle status change logic
                if (newStatus !== status) {
                    if ((status === "constant" || status === "descending") && newStatus === "ascending" ) {
                    if (mountainStart !== null) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = i;
                        mountainEnd = null;                
                    }
                    else{
                        mountainStart = mountainStart === null ? i : mountainStart;
                    }
                        
                    } 
                    else if (status === "descending" && mountainStart !== null && (newStatus === "constant" )) {
                        mountainEnd = i;
                        mountains.push({ start: mountainStart, end: mountainEnd });
                        mountainStart = null;
                        mountainEnd = null;
                    }          

                    // Update status
                    //console.log(status, newStatus);
                    status = newStatus;
                    
                }
            }
            // Find the global minimum and maximum values in arr
            const globalMin = Math.min(...array);
            const globalMax = Math.max(...array);
            const globalDistance = globalMax - globalMin;
            // Validate and extract real mountains
            const realMountains = mountains.filter(({ start, end }) => {
            const fragment = array.slice(start, end + 1); // Get the fragment of arr
            const fragmentMin = Math.min(...fragment);
            const fragmentMax = Math.max(...fragment);
            const fragmentDistance = fragmentMax - fragmentMin;

            // Compare fragment distance to x% of global distance
            return fragmentDistance >= (height / 100) * globalDistance;
            });
            return realMountains;
        }

        function extractTrackData(draggable_coordinates, baselines) {
            // Uzyskanie dostpu do g贸wnego canvas
            const mainCanvas = document.getElementById('normalised');
            const mainCtx = mainCanvas.getContext('2d');
            const kernelSize = parseInt(document.getElementById('kernelSize').value);
            draggable_coordinates.forEach(coordinate => {
                // Wydobywanie danych z ImageData dla podanych wsp贸rzdnych
                const imageData = mainCtx.getImageData(baselines.x, coordinate.y, baselines.width, coordinate.height);
                // Tworzenie nowego canvas i kontekstu
                const newCanvas = document.createElement('canvas');
                const newCtx = newCanvas.getContext('2d');

                // Ustawianie rozmiaru nowego canvas
                newCanvas.width = baselines.width;
                newCanvas.height = coordinate.height;

                // Wstawianie ImageData do nowego canvas
                newCtx.putImageData(imageData, 0, 0);

                // Tworzenie nowego div'a z odpowiednim id
                const newDiv = document.createElement('div');
                newDiv.id = coordinate.name;  // Ustawianie id div'a na podstawie 'name' w draggable_coordinates

                // Tworzenie tablicy 1D z sumami kanau czerwonego dla ka偶dej kolumny
                const RedSums = [];
                for (let x = 0; x < imageData.width; x++) {
                    let sumRed = 0;
                    for (let y = 0; y < imageData.height; y++) {
                        const index = (y * imageData.width + x) * 4;
                        sumRed += 255 - imageData.data[index]; // Kana czerwony to pierwszy element w tablicy (index * 4)
                    }

                    RedSums.push(sumRed); // Zapisanie sumy kanau czerwonego dla ka偶dej kolumny
                }
                
                const blurredRedSums = blurArray(RedSums, kernelSize);
                const mountains = analyzeArrayWithKernel(blurredRedSums, 1, 1);
                console.log(mountains);
                // Normalizacja RedSums (zakadajc, 偶e minimalna warto to 0, a maksymalna to 250)
                const min = Math.min(...RedSums);
                const max = Math.max(...RedSums);
                const normalizedRedSums = RedSums.map(value => (value - min) / (max - min) * 250);
                
                // Dodanie atrybutu data-red-sums do div'a z 1D tablic RedSums
                newDiv.dataset.RedSums = JSON.stringify(RedSums);  // U偶ycie data-* atrybutu
                newDiv.dataset.blurRedredSums = JSON.stringify(blurredRedSums); 
                // Tworzenie g贸wnego canvas
                const mainCanvas = document.createElement('canvas');
                mainCanvas.width = newCanvas.width;
                mainCanvas.height = 250;
                const ctx = mainCanvas.getContext('2d');

                // Rysowanie wykresu jako linia
                ctx.beginPath();
                ctx.strokeStyle = 'steelblue';
                ctx.lineWidth = 2;
                normalizedRedSums.forEach((value, index) => {
                    const x = (index / (normalizedRedSums.length - 1)) * mainCanvas.width;
                    const y = 250 - value;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();

                const header = document.createElement('h2');
                header.textContent = coordinate.name;
                newDiv.appendChild(header);
                // Dodanie canvas z wykresem do div'a
                newDiv.appendChild(mainCanvas);

                // Dodanie br pomidzy canvasami
                newDiv.appendChild(document.createElement('br'));

                // Dodanie canvas do div'a
                newDiv.appendChild(newCanvas);

                // Dodanie div'a do dokumentu (np. do body)
                document.body.appendChild(newDiv);
            });
        }



    </script>     
</body>
</html>
