<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Load and Crop Image</title>
</head>
<body>
    <h1>Image Viewer</h1>
    <canvas id="canvas" style="border: solid 1px black;"></canvas>
    <br>
    <canvas id="chart" style="border: solid 1px black;"></canvas>
    <button onclick="findSpots()">Process Image</button>
    <input type="number" min="0" max="255" value="240" id="treshold">
    
    <script>
        const nameBcg = 'normalised_image'; // The name of the image to load from IndexedDB
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const chart = document.getElementById('canvas');
        const chart_ctx = canvas.getContext('2d');

        const loadImage = () => {
            const request = indexedDB.open("ImageDB", 1);
            request.onsuccess = function(event) {
                const db = event.target.result;
                const transaction = db.transaction(["images"], "readonly");
                const store = transaction.objectStore("images");
                const bcgRequest = store.get(nameBcg);

                bcgRequest.onsuccess = function() {
                    const imageDataUrl = bcgRequest.result;
                    if (imageDataUrl) {
                        // Check if the result is a Data URL (base64 string)
                        if (typeof imageDataUrl === 'string' && imageDataUrl.startsWith('data:image/png;base64')) {
                            const img = new Image();
                            img.src = imageDataUrl;  // Directly use the base64 string as the image source
                            img.onload = () => {
                                // Set canvas size to match image
                                canvas.width = img.width;
                                canvas.height = img.height;
                                ctx.drawImage(img, 0, 0);
                                loadPixelCoordinates(); // Once image is loaded, load pixel coordinates
                            };
                        } else {
                            console.error("Expected a Data URL (base64 string), but got:", imageDataUrl);
                        }
                    } else {
                        console.error("Image not found.");
                    }
                };
            };
        };

        // Load pixel coordinates from 'ParametryDB' to crop the image
        const loadPixelCoordinates = () => {
            const request = indexedDB.open("ParametryDB", 1);
            request.onsuccess = function(event) {
                const db = event.target.result;
                const transaction = db.transaction("parametry", "readonly");
                const store = transaction.objectStore("parametry");
                const getRequest = store.get("pixel_coords");

                getRequest.onsuccess = function() {
                    const coords = getRequest.result;
                    if (coords) {
                        // Assume coords is an object with 'x', 'y', 'width', 'height' for cropping
                        const { top, height, left, width } = coords;
                        // Crop the image based on the coordinates and display on canvas
                        const croppedImage = ctx.getImageData(left, top, width, height);
                        canvas.width = width;
                        canvas.height = height;
                        ctx.putImageData(croppedImage, 0, 0);
                    } else {
                        console.error("Pixel coordinates not found.");
                    }
                };
            };
        };

        const findSpots = () => {
            const threshold = parseInt(document.getElementById('treshold').value); // Get threshold from input
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data; // Image data array (RGBA values)

            // First pass: Modify the image data based on the threshold
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];     // Red channel
                const g = data[i + 1]; // Green channel
                const b = data[i + 2]; // Blue channel
                const a = data[i + 3]; // Alpha channel

                // Check if the pixel's brightness exceeds the threshold
                if (r > threshold) {
                    // Set blue channel and alpha to specific values if condition is met
                    data[i + 2] = 192; // Set blue channel to a fixed value
                    data[i + 3] = 64;  // Set alpha channel to a fixed value
                }
            }

            let result = [];
            // Iterate over rows
            for (let x = 0; x < canvas.width; x++) {
                let rowSum = 0;
                const maxRowSum = 255 * canvas.height; // Max possible sum for the row (255 * number of pixels)

                // Iterate over pixels in the row (y from 0 to canvas height)
                for (let y = 0; y < canvas.height; y++) {
                    const i = (y * canvas.width + x) * 4; // Get the index of the pixel in the 1D array

                    const r = data[i];     // Red channel
                    const g = data[i + 1]; // Green channel
                    const b = data[i + 2]; // Blue channel
                    const a = data[i + 3]; // Alpha channel

                    let pixelValue = r; // Default value is the red channel

                    // Check if alpha is 64 and blue is 192 (processed condition)
                    if (a === 64 && b === 192) {
                        pixelValue = 255; // If condition met, set pixel value to 255
                    }

                    rowSum += pixelValue; // Add the pixel value to the sum for the row
                }

                // Subtract the row sum from the max row sum and normalize
                const normalizedRowValue = (maxRowSum - rowSum) / maxRowSum;
                result.push(normalizedRowValue); // Store the result
            }
            drawChart(result);
            // Put the modified image data back onto the canvas
            ctx.putImageData(imageData, 0, 0);
        };

        function drawChart(result){
            // Normalize the result values to the range [0, 255]
            const minResult = Math.min(...result);
            const maxResult = Math.max(...result);
            
            // If max and min values are the same, prevent division by zero
            const range = maxResult - minResult;
            const normalizedResult = result.map(value => (range === 0) ? 0 : ((value - minResult) / range) * 255);
            
            // Clear the canvas before drawing
            chart_ctx.clearRect(0, 0, chart.width, chart.height);
            
            // Set the line style (2px black line)
            chart_ctx.lineWidth = 2;
            chart_ctx.strokeStyle = 'black';
            
            // Begin drawing the line
            chart_ctx.beginPath();
            
            // Start at the first point
            chart_ctx.moveTo(0, 255 - normalizedResult[0]); // Invert the value because canvas y-axis starts from top
            
            // Draw line through all the points
            for (let i = 1; i < normalizedResult.length; i++) {
                chart_ctx.lineTo(i, 255 - normalizedResult[i]); // Invert y-axis values
            }
            
            // Stroke the path
            chart_ctx.stroke();
        }
        // Load the image when the page is ready
        loadImage();
    </script>
</body>
</html>
